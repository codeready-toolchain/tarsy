// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/codeready-toolchain/tarsy/ent/agentexecution"
	"github.com/codeready-toolchain/tarsy/ent/alertsession"
	"github.com/codeready-toolchain/tarsy/ent/chat"
	"github.com/codeready-toolchain/tarsy/ent/chatusermessage"
	"github.com/codeready-toolchain/tarsy/ent/event"
	"github.com/codeready-toolchain/tarsy/ent/llminteraction"
	"github.com/codeready-toolchain/tarsy/ent/mcpinteraction"
	"github.com/codeready-toolchain/tarsy/ent/message"
	"github.com/codeready-toolchain/tarsy/ent/predicate"
	"github.com/codeready-toolchain/tarsy/ent/stage"
	"github.com/codeready-toolchain/tarsy/ent/timelineevent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgentExecution  = "AgentExecution"
	TypeAlertSession    = "AlertSession"
	TypeChat            = "Chat"
	TypeChatUserMessage = "ChatUserMessage"
	TypeEvent           = "Event"
	TypeLLMInteraction  = "LLMInteraction"
	TypeMCPInteraction  = "MCPInteraction"
	TypeMessage         = "Message"
	TypeStage           = "Stage"
	TypeTimelineEvent   = "TimelineEvent"
)

// AgentExecutionMutation represents an operation that mutates the AgentExecution nodes in the graph.
type AgentExecutionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	agent_name              *string
	agent_index             *int
	addagent_index          *int
	status                  *agentexecution.Status
	started_at              *time.Time
	completed_at            *time.Time
	duration_ms             *int
	addduration_ms          *int
	error_message           *string
	iteration_strategy      *string
	clearedFields           map[string]struct{}
	stage                   *string
	clearedstage            bool
	session                 *string
	clearedsession          bool
	timeline_events         map[string]struct{}
	removedtimeline_events  map[string]struct{}
	clearedtimeline_events  bool
	messages                map[string]struct{}
	removedmessages         map[string]struct{}
	clearedmessages         bool
	llm_interactions        map[string]struct{}
	removedllm_interactions map[string]struct{}
	clearedllm_interactions bool
	mcp_interactions        map[string]struct{}
	removedmcp_interactions map[string]struct{}
	clearedmcp_interactions bool
	done                    bool
	oldValue                func(context.Context) (*AgentExecution, error)
	predicates              []predicate.AgentExecution
}

var _ ent.Mutation = (*AgentExecutionMutation)(nil)

// agentexecutionOption allows management of the mutation configuration using functional options.
type agentexecutionOption func(*AgentExecutionMutation)

// newAgentExecutionMutation creates new mutation for the AgentExecution entity.
func newAgentExecutionMutation(c config, op Op, opts ...agentexecutionOption) *AgentExecutionMutation {
	m := &AgentExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentExecutionID sets the ID field of the mutation.
func withAgentExecutionID(id string) agentexecutionOption {
	return func(m *AgentExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *AgentExecution
		)
		m.oldValue = func(ctx context.Context) (*AgentExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AgentExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentExecution sets the old AgentExecution of the mutation.
func withAgentExecution(node *AgentExecution) agentexecutionOption {
	return func(m *AgentExecutionMutation) {
		m.oldValue = func(context.Context) (*AgentExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AgentExecution entities.
func (m *AgentExecutionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentExecutionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentExecutionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AgentExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStageID sets the "stage_id" field.
func (m *AgentExecutionMutation) SetStageID(s string) {
	m.stage = &s
}

// StageID returns the value of the "stage_id" field in the mutation.
func (m *AgentExecutionMutation) StageID() (r string, exists bool) {
	v := m.stage
	if v == nil {
		return
	}
	return *v, true
}

// OldStageID returns the old "stage_id" field's value of the AgentExecution entity.
// If the AgentExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentExecutionMutation) OldStageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStageID: %w", err)
	}
	return oldValue.StageID, nil
}

// ResetStageID resets all changes to the "stage_id" field.
func (m *AgentExecutionMutation) ResetStageID() {
	m.stage = nil
}

// SetSessionID sets the "session_id" field.
func (m *AgentExecutionMutation) SetSessionID(s string) {
	m.session = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *AgentExecutionMutation) SessionID() (r string, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the AgentExecution entity.
// If the AgentExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentExecutionMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *AgentExecutionMutation) ResetSessionID() {
	m.session = nil
}

// SetAgentName sets the "agent_name" field.
func (m *AgentExecutionMutation) SetAgentName(s string) {
	m.agent_name = &s
}

// AgentName returns the value of the "agent_name" field in the mutation.
func (m *AgentExecutionMutation) AgentName() (r string, exists bool) {
	v := m.agent_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentName returns the old "agent_name" field's value of the AgentExecution entity.
// If the AgentExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentExecutionMutation) OldAgentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentName: %w", err)
	}
	return oldValue.AgentName, nil
}

// ResetAgentName resets all changes to the "agent_name" field.
func (m *AgentExecutionMutation) ResetAgentName() {
	m.agent_name = nil
}

// SetAgentIndex sets the "agent_index" field.
func (m *AgentExecutionMutation) SetAgentIndex(i int) {
	m.agent_index = &i
	m.addagent_index = nil
}

// AgentIndex returns the value of the "agent_index" field in the mutation.
func (m *AgentExecutionMutation) AgentIndex() (r int, exists bool) {
	v := m.agent_index
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentIndex returns the old "agent_index" field's value of the AgentExecution entity.
// If the AgentExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentExecutionMutation) OldAgentIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentIndex: %w", err)
	}
	return oldValue.AgentIndex, nil
}

// AddAgentIndex adds i to the "agent_index" field.
func (m *AgentExecutionMutation) AddAgentIndex(i int) {
	if m.addagent_index != nil {
		*m.addagent_index += i
	} else {
		m.addagent_index = &i
	}
}

// AddedAgentIndex returns the value that was added to the "agent_index" field in this mutation.
func (m *AgentExecutionMutation) AddedAgentIndex() (r int, exists bool) {
	v := m.addagent_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetAgentIndex resets all changes to the "agent_index" field.
func (m *AgentExecutionMutation) ResetAgentIndex() {
	m.agent_index = nil
	m.addagent_index = nil
}

// SetStatus sets the "status" field.
func (m *AgentExecutionMutation) SetStatus(a agentexecution.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AgentExecutionMutation) Status() (r agentexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AgentExecution entity.
// If the AgentExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentExecutionMutation) OldStatus(ctx context.Context) (v agentexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AgentExecutionMutation) ResetStatus() {
	m.status = nil
}

// SetStartedAt sets the "started_at" field.
func (m *AgentExecutionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *AgentExecutionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the AgentExecution entity.
// If the AgentExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentExecutionMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *AgentExecutionMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[agentexecution.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *AgentExecutionMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[agentexecution.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *AgentExecutionMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, agentexecution.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *AgentExecutionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *AgentExecutionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the AgentExecution entity.
// If the AgentExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentExecutionMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *AgentExecutionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[agentexecution.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *AgentExecutionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[agentexecution.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *AgentExecutionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, agentexecution.FieldCompletedAt)
}

// SetDurationMs sets the "duration_ms" field.
func (m *AgentExecutionMutation) SetDurationMs(i int) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *AgentExecutionMutation) DurationMs() (r int, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the AgentExecution entity.
// If the AgentExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentExecutionMutation) OldDurationMs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *AgentExecutionMutation) AddDurationMs(i int) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *AgentExecutionMutation) AddedDurationMs() (r int, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *AgentExecutionMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[agentexecution.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *AgentExecutionMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[agentexecution.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *AgentExecutionMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, agentexecution.FieldDurationMs)
}

// SetErrorMessage sets the "error_message" field.
func (m *AgentExecutionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AgentExecutionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AgentExecution entity.
// If the AgentExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentExecutionMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AgentExecutionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[agentexecution.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AgentExecutionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[agentexecution.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AgentExecutionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, agentexecution.FieldErrorMessage)
}

// SetIterationStrategy sets the "iteration_strategy" field.
func (m *AgentExecutionMutation) SetIterationStrategy(s string) {
	m.iteration_strategy = &s
}

// IterationStrategy returns the value of the "iteration_strategy" field in the mutation.
func (m *AgentExecutionMutation) IterationStrategy() (r string, exists bool) {
	v := m.iteration_strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldIterationStrategy returns the old "iteration_strategy" field's value of the AgentExecution entity.
// If the AgentExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentExecutionMutation) OldIterationStrategy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIterationStrategy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIterationStrategy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIterationStrategy: %w", err)
	}
	return oldValue.IterationStrategy, nil
}

// ResetIterationStrategy resets all changes to the "iteration_strategy" field.
func (m *AgentExecutionMutation) ResetIterationStrategy() {
	m.iteration_strategy = nil
}

// ClearStage clears the "stage" edge to the Stage entity.
func (m *AgentExecutionMutation) ClearStage() {
	m.clearedstage = true
	m.clearedFields[agentexecution.FieldStageID] = struct{}{}
}

// StageCleared reports if the "stage" edge to the Stage entity was cleared.
func (m *AgentExecutionMutation) StageCleared() bool {
	return m.clearedstage
}

// StageIDs returns the "stage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageID instead. It exists only for internal usage by the builders.
func (m *AgentExecutionMutation) StageIDs() (ids []string) {
	if id := m.stage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStage resets all changes to the "stage" edge.
func (m *AgentExecutionMutation) ResetStage() {
	m.stage = nil
	m.clearedstage = false
}

// ClearSession clears the "session" edge to the AlertSession entity.
func (m *AgentExecutionMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[agentexecution.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the AlertSession entity was cleared.
func (m *AgentExecutionMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *AgentExecutionMutation) SessionIDs() (ids []string) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *AgentExecutionMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// AddTimelineEventIDs adds the "timeline_events" edge to the TimelineEvent entity by ids.
func (m *AgentExecutionMutation) AddTimelineEventIDs(ids ...string) {
	if m.timeline_events == nil {
		m.timeline_events = make(map[string]struct{})
	}
	for i := range ids {
		m.timeline_events[ids[i]] = struct{}{}
	}
}

// ClearTimelineEvents clears the "timeline_events" edge to the TimelineEvent entity.
func (m *AgentExecutionMutation) ClearTimelineEvents() {
	m.clearedtimeline_events = true
}

// TimelineEventsCleared reports if the "timeline_events" edge to the TimelineEvent entity was cleared.
func (m *AgentExecutionMutation) TimelineEventsCleared() bool {
	return m.clearedtimeline_events
}

// RemoveTimelineEventIDs removes the "timeline_events" edge to the TimelineEvent entity by IDs.
func (m *AgentExecutionMutation) RemoveTimelineEventIDs(ids ...string) {
	if m.removedtimeline_events == nil {
		m.removedtimeline_events = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.timeline_events, ids[i])
		m.removedtimeline_events[ids[i]] = struct{}{}
	}
}

// RemovedTimelineEvents returns the removed IDs of the "timeline_events" edge to the TimelineEvent entity.
func (m *AgentExecutionMutation) RemovedTimelineEventsIDs() (ids []string) {
	for id := range m.removedtimeline_events {
		ids = append(ids, id)
	}
	return
}

// TimelineEventsIDs returns the "timeline_events" edge IDs in the mutation.
func (m *AgentExecutionMutation) TimelineEventsIDs() (ids []string) {
	for id := range m.timeline_events {
		ids = append(ids, id)
	}
	return
}

// ResetTimelineEvents resets all changes to the "timeline_events" edge.
func (m *AgentExecutionMutation) ResetTimelineEvents() {
	m.timeline_events = nil
	m.clearedtimeline_events = false
	m.removedtimeline_events = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *AgentExecutionMutation) AddMessageIDs(ids ...string) {
	if m.messages == nil {
		m.messages = make(map[string]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *AgentExecutionMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *AgentExecutionMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *AgentExecutionMutation) RemoveMessageIDs(ids ...string) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *AgentExecutionMutation) RemovedMessagesIDs() (ids []string) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *AgentExecutionMutation) MessagesIDs() (ids []string) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *AgentExecutionMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddLlmInteractionIDs adds the "llm_interactions" edge to the LLMInteraction entity by ids.
func (m *AgentExecutionMutation) AddLlmInteractionIDs(ids ...string) {
	if m.llm_interactions == nil {
		m.llm_interactions = make(map[string]struct{})
	}
	for i := range ids {
		m.llm_interactions[ids[i]] = struct{}{}
	}
}

// ClearLlmInteractions clears the "llm_interactions" edge to the LLMInteraction entity.
func (m *AgentExecutionMutation) ClearLlmInteractions() {
	m.clearedllm_interactions = true
}

// LlmInteractionsCleared reports if the "llm_interactions" edge to the LLMInteraction entity was cleared.
func (m *AgentExecutionMutation) LlmInteractionsCleared() bool {
	return m.clearedllm_interactions
}

// RemoveLlmInteractionIDs removes the "llm_interactions" edge to the LLMInteraction entity by IDs.
func (m *AgentExecutionMutation) RemoveLlmInteractionIDs(ids ...string) {
	if m.removedllm_interactions == nil {
		m.removedllm_interactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.llm_interactions, ids[i])
		m.removedllm_interactions[ids[i]] = struct{}{}
	}
}

// RemovedLlmInteractions returns the removed IDs of the "llm_interactions" edge to the LLMInteraction entity.
func (m *AgentExecutionMutation) RemovedLlmInteractionsIDs() (ids []string) {
	for id := range m.removedllm_interactions {
		ids = append(ids, id)
	}
	return
}

// LlmInteractionsIDs returns the "llm_interactions" edge IDs in the mutation.
func (m *AgentExecutionMutation) LlmInteractionsIDs() (ids []string) {
	for id := range m.llm_interactions {
		ids = append(ids, id)
	}
	return
}

// ResetLlmInteractions resets all changes to the "llm_interactions" edge.
func (m *AgentExecutionMutation) ResetLlmInteractions() {
	m.llm_interactions = nil
	m.clearedllm_interactions = false
	m.removedllm_interactions = nil
}

// AddMcpInteractionIDs adds the "mcp_interactions" edge to the MCPInteraction entity by ids.
func (m *AgentExecutionMutation) AddMcpInteractionIDs(ids ...string) {
	if m.mcp_interactions == nil {
		m.mcp_interactions = make(map[string]struct{})
	}
	for i := range ids {
		m.mcp_interactions[ids[i]] = struct{}{}
	}
}

// ClearMcpInteractions clears the "mcp_interactions" edge to the MCPInteraction entity.
func (m *AgentExecutionMutation) ClearMcpInteractions() {
	m.clearedmcp_interactions = true
}

// McpInteractionsCleared reports if the "mcp_interactions" edge to the MCPInteraction entity was cleared.
func (m *AgentExecutionMutation) McpInteractionsCleared() bool {
	return m.clearedmcp_interactions
}

// RemoveMcpInteractionIDs removes the "mcp_interactions" edge to the MCPInteraction entity by IDs.
func (m *AgentExecutionMutation) RemoveMcpInteractionIDs(ids ...string) {
	if m.removedmcp_interactions == nil {
		m.removedmcp_interactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.mcp_interactions, ids[i])
		m.removedmcp_interactions[ids[i]] = struct{}{}
	}
}

// RemovedMcpInteractions returns the removed IDs of the "mcp_interactions" edge to the MCPInteraction entity.
func (m *AgentExecutionMutation) RemovedMcpInteractionsIDs() (ids []string) {
	for id := range m.removedmcp_interactions {
		ids = append(ids, id)
	}
	return
}

// McpInteractionsIDs returns the "mcp_interactions" edge IDs in the mutation.
func (m *AgentExecutionMutation) McpInteractionsIDs() (ids []string) {
	for id := range m.mcp_interactions {
		ids = append(ids, id)
	}
	return
}

// ResetMcpInteractions resets all changes to the "mcp_interactions" edge.
func (m *AgentExecutionMutation) ResetMcpInteractions() {
	m.mcp_interactions = nil
	m.clearedmcp_interactions = false
	m.removedmcp_interactions = nil
}

// Where appends a list predicates to the AgentExecutionMutation builder.
func (m *AgentExecutionMutation) Where(ps ...predicate.AgentExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AgentExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AgentExecution).
func (m *AgentExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentExecutionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.stage != nil {
		fields = append(fields, agentexecution.FieldStageID)
	}
	if m.session != nil {
		fields = append(fields, agentexecution.FieldSessionID)
	}
	if m.agent_name != nil {
		fields = append(fields, agentexecution.FieldAgentName)
	}
	if m.agent_index != nil {
		fields = append(fields, agentexecution.FieldAgentIndex)
	}
	if m.status != nil {
		fields = append(fields, agentexecution.FieldStatus)
	}
	if m.started_at != nil {
		fields = append(fields, agentexecution.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, agentexecution.FieldCompletedAt)
	}
	if m.duration_ms != nil {
		fields = append(fields, agentexecution.FieldDurationMs)
	}
	if m.error_message != nil {
		fields = append(fields, agentexecution.FieldErrorMessage)
	}
	if m.iteration_strategy != nil {
		fields = append(fields, agentexecution.FieldIterationStrategy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agentexecution.FieldStageID:
		return m.StageID()
	case agentexecution.FieldSessionID:
		return m.SessionID()
	case agentexecution.FieldAgentName:
		return m.AgentName()
	case agentexecution.FieldAgentIndex:
		return m.AgentIndex()
	case agentexecution.FieldStatus:
		return m.Status()
	case agentexecution.FieldStartedAt:
		return m.StartedAt()
	case agentexecution.FieldCompletedAt:
		return m.CompletedAt()
	case agentexecution.FieldDurationMs:
		return m.DurationMs()
	case agentexecution.FieldErrorMessage:
		return m.ErrorMessage()
	case agentexecution.FieldIterationStrategy:
		return m.IterationStrategy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agentexecution.FieldStageID:
		return m.OldStageID(ctx)
	case agentexecution.FieldSessionID:
		return m.OldSessionID(ctx)
	case agentexecution.FieldAgentName:
		return m.OldAgentName(ctx)
	case agentexecution.FieldAgentIndex:
		return m.OldAgentIndex(ctx)
	case agentexecution.FieldStatus:
		return m.OldStatus(ctx)
	case agentexecution.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case agentexecution.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case agentexecution.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case agentexecution.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case agentexecution.FieldIterationStrategy:
		return m.OldIterationStrategy(ctx)
	}
	return nil, fmt.Errorf("unknown AgentExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agentexecution.FieldStageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStageID(v)
		return nil
	case agentexecution.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case agentexecution.FieldAgentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentName(v)
		return nil
	case agentexecution.FieldAgentIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentIndex(v)
		return nil
	case agentexecution.FieldStatus:
		v, ok := value.(agentexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case agentexecution.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case agentexecution.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case agentexecution.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case agentexecution.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case agentexecution.FieldIterationStrategy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIterationStrategy(v)
		return nil
	}
	return fmt.Errorf("unknown AgentExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentExecutionMutation) AddedFields() []string {
	var fields []string
	if m.addagent_index != nil {
		fields = append(fields, agentexecution.FieldAgentIndex)
	}
	if m.addduration_ms != nil {
		fields = append(fields, agentexecution.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agentexecution.FieldAgentIndex:
		return m.AddedAgentIndex()
	case agentexecution.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agentexecution.FieldAgentIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAgentIndex(v)
		return nil
	case agentexecution.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown AgentExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agentexecution.FieldStartedAt) {
		fields = append(fields, agentexecution.FieldStartedAt)
	}
	if m.FieldCleared(agentexecution.FieldCompletedAt) {
		fields = append(fields, agentexecution.FieldCompletedAt)
	}
	if m.FieldCleared(agentexecution.FieldDurationMs) {
		fields = append(fields, agentexecution.FieldDurationMs)
	}
	if m.FieldCleared(agentexecution.FieldErrorMessage) {
		fields = append(fields, agentexecution.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentExecutionMutation) ClearField(name string) error {
	switch name {
	case agentexecution.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case agentexecution.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case agentexecution.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	case agentexecution.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown AgentExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentExecutionMutation) ResetField(name string) error {
	switch name {
	case agentexecution.FieldStageID:
		m.ResetStageID()
		return nil
	case agentexecution.FieldSessionID:
		m.ResetSessionID()
		return nil
	case agentexecution.FieldAgentName:
		m.ResetAgentName()
		return nil
	case agentexecution.FieldAgentIndex:
		m.ResetAgentIndex()
		return nil
	case agentexecution.FieldStatus:
		m.ResetStatus()
		return nil
	case agentexecution.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case agentexecution.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case agentexecution.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case agentexecution.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case agentexecution.FieldIterationStrategy:
		m.ResetIterationStrategy()
		return nil
	}
	return fmt.Errorf("unknown AgentExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.stage != nil {
		edges = append(edges, agentexecution.EdgeStage)
	}
	if m.session != nil {
		edges = append(edges, agentexecution.EdgeSession)
	}
	if m.timeline_events != nil {
		edges = append(edges, agentexecution.EdgeTimelineEvents)
	}
	if m.messages != nil {
		edges = append(edges, agentexecution.EdgeMessages)
	}
	if m.llm_interactions != nil {
		edges = append(edges, agentexecution.EdgeLlmInteractions)
	}
	if m.mcp_interactions != nil {
		edges = append(edges, agentexecution.EdgeMcpInteractions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agentexecution.EdgeStage:
		if id := m.stage; id != nil {
			return []ent.Value{*id}
		}
	case agentexecution.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case agentexecution.EdgeTimelineEvents:
		ids := make([]ent.Value, 0, len(m.timeline_events))
		for id := range m.timeline_events {
			ids = append(ids, id)
		}
		return ids
	case agentexecution.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case agentexecution.EdgeLlmInteractions:
		ids := make([]ent.Value, 0, len(m.llm_interactions))
		for id := range m.llm_interactions {
			ids = append(ids, id)
		}
		return ids
	case agentexecution.EdgeMcpInteractions:
		ids := make([]ent.Value, 0, len(m.mcp_interactions))
		for id := range m.mcp_interactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedtimeline_events != nil {
		edges = append(edges, agentexecution.EdgeTimelineEvents)
	}
	if m.removedmessages != nil {
		edges = append(edges, agentexecution.EdgeMessages)
	}
	if m.removedllm_interactions != nil {
		edges = append(edges, agentexecution.EdgeLlmInteractions)
	}
	if m.removedmcp_interactions != nil {
		edges = append(edges, agentexecution.EdgeMcpInteractions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentExecutionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agentexecution.EdgeTimelineEvents:
		ids := make([]ent.Value, 0, len(m.removedtimeline_events))
		for id := range m.removedtimeline_events {
			ids = append(ids, id)
		}
		return ids
	case agentexecution.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case agentexecution.EdgeLlmInteractions:
		ids := make([]ent.Value, 0, len(m.removedllm_interactions))
		for id := range m.removedllm_interactions {
			ids = append(ids, id)
		}
		return ids
	case agentexecution.EdgeMcpInteractions:
		ids := make([]ent.Value, 0, len(m.removedmcp_interactions))
		for id := range m.removedmcp_interactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedstage {
		edges = append(edges, agentexecution.EdgeStage)
	}
	if m.clearedsession {
		edges = append(edges, agentexecution.EdgeSession)
	}
	if m.clearedtimeline_events {
		edges = append(edges, agentexecution.EdgeTimelineEvents)
	}
	if m.clearedmessages {
		edges = append(edges, agentexecution.EdgeMessages)
	}
	if m.clearedllm_interactions {
		edges = append(edges, agentexecution.EdgeLlmInteractions)
	}
	if m.clearedmcp_interactions {
		edges = append(edges, agentexecution.EdgeMcpInteractions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case agentexecution.EdgeStage:
		return m.clearedstage
	case agentexecution.EdgeSession:
		return m.clearedsession
	case agentexecution.EdgeTimelineEvents:
		return m.clearedtimeline_events
	case agentexecution.EdgeMessages:
		return m.clearedmessages
	case agentexecution.EdgeLlmInteractions:
		return m.clearedllm_interactions
	case agentexecution.EdgeMcpInteractions:
		return m.clearedmcp_interactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentExecutionMutation) ClearEdge(name string) error {
	switch name {
	case agentexecution.EdgeStage:
		m.ClearStage()
		return nil
	case agentexecution.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown AgentExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentExecutionMutation) ResetEdge(name string) error {
	switch name {
	case agentexecution.EdgeStage:
		m.ResetStage()
		return nil
	case agentexecution.EdgeSession:
		m.ResetSession()
		return nil
	case agentexecution.EdgeTimelineEvents:
		m.ResetTimelineEvents()
		return nil
	case agentexecution.EdgeMessages:
		m.ResetMessages()
		return nil
	case agentexecution.EdgeLlmInteractions:
		m.ResetLlmInteractions()
		return nil
	case agentexecution.EdgeMcpInteractions:
		m.ResetMcpInteractions()
		return nil
	}
	return fmt.Errorf("unknown AgentExecution edge %s", name)
}

// AlertSessionMutation represents an operation that mutates the AlertSession nodes in the graph.
type AlertSessionMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	alert_data                *string
	agent_type                *string
	alert_type                *string
	status                    *alertsession.Status
	started_at                *time.Time
	completed_at              *time.Time
	error_message             *string
	final_analysis            *string
	executive_summary         *string
	executive_summary_error   *string
	session_metadata          *map[string]interface{}
	author                    *string
	runbook_url               *string
	mcp_selection             *map[string]interface{}
	chain_id                  *string
	current_stage_index       *int
	addcurrent_stage_index    *int
	current_stage_id          *string
	pod_id                    *string
	last_interaction_at       *time.Time
	slack_message_fingerprint *string
	deleted_at                *time.Time
	clearedFields             map[string]struct{}
	stages                    map[string]struct{}
	removedstages             map[string]struct{}
	clearedstages             bool
	agent_executions          map[string]struct{}
	removedagent_executions   map[string]struct{}
	clearedagent_executions   bool
	timeline_events           map[string]struct{}
	removedtimeline_events    map[string]struct{}
	clearedtimeline_events    bool
	messages                  map[string]struct{}
	removedmessages           map[string]struct{}
	clearedmessages           bool
	llm_interactions          map[string]struct{}
	removedllm_interactions   map[string]struct{}
	clearedllm_interactions   bool
	mcp_interactions          map[string]struct{}
	removedmcp_interactions   map[string]struct{}
	clearedmcp_interactions   bool
	events                    map[int]struct{}
	removedevents             map[int]struct{}
	clearedevents             bool
	chat                      *string
	clearedchat               bool
	done                      bool
	oldValue                  func(context.Context) (*AlertSession, error)
	predicates                []predicate.AlertSession
}

var _ ent.Mutation = (*AlertSessionMutation)(nil)

// alertsessionOption allows management of the mutation configuration using functional options.
type alertsessionOption func(*AlertSessionMutation)

// newAlertSessionMutation creates new mutation for the AlertSession entity.
func newAlertSessionMutation(c config, op Op, opts ...alertsessionOption) *AlertSessionMutation {
	m := &AlertSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeAlertSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertSessionID sets the ID field of the mutation.
func withAlertSessionID(id string) alertsessionOption {
	return func(m *AlertSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *AlertSession
		)
		m.oldValue = func(ctx context.Context) (*AlertSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlertSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlertSession sets the old AlertSession of the mutation.
func withAlertSession(node *AlertSession) alertsessionOption {
	return func(m *AlertSessionMutation) {
		m.oldValue = func(context.Context) (*AlertSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlertSession entities.
func (m *AlertSessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertSessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertSessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlertSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlertData sets the "alert_data" field.
func (m *AlertSessionMutation) SetAlertData(s string) {
	m.alert_data = &s
}

// AlertData returns the value of the "alert_data" field in the mutation.
func (m *AlertSessionMutation) AlertData() (r string, exists bool) {
	v := m.alert_data
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertData returns the old "alert_data" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldAlertData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertData: %w", err)
	}
	return oldValue.AlertData, nil
}

// ResetAlertData resets all changes to the "alert_data" field.
func (m *AlertSessionMutation) ResetAlertData() {
	m.alert_data = nil
}

// SetAgentType sets the "agent_type" field.
func (m *AlertSessionMutation) SetAgentType(s string) {
	m.agent_type = &s
}

// AgentType returns the value of the "agent_type" field in the mutation.
func (m *AlertSessionMutation) AgentType() (r string, exists bool) {
	v := m.agent_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentType returns the old "agent_type" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldAgentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentType: %w", err)
	}
	return oldValue.AgentType, nil
}

// ResetAgentType resets all changes to the "agent_type" field.
func (m *AlertSessionMutation) ResetAgentType() {
	m.agent_type = nil
}

// SetAlertType sets the "alert_type" field.
func (m *AlertSessionMutation) SetAlertType(s string) {
	m.alert_type = &s
}

// AlertType returns the value of the "alert_type" field in the mutation.
func (m *AlertSessionMutation) AlertType() (r string, exists bool) {
	v := m.alert_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAlertType returns the old "alert_type" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldAlertType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlertType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlertType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlertType: %w", err)
	}
	return oldValue.AlertType, nil
}

// ClearAlertType clears the value of the "alert_type" field.
func (m *AlertSessionMutation) ClearAlertType() {
	m.alert_type = nil
	m.clearedFields[alertsession.FieldAlertType] = struct{}{}
}

// AlertTypeCleared returns if the "alert_type" field was cleared in this mutation.
func (m *AlertSessionMutation) AlertTypeCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldAlertType]
	return ok
}

// ResetAlertType resets all changes to the "alert_type" field.
func (m *AlertSessionMutation) ResetAlertType() {
	m.alert_type = nil
	delete(m.clearedFields, alertsession.FieldAlertType)
}

// SetStatus sets the "status" field.
func (m *AlertSessionMutation) SetStatus(a alertsession.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AlertSessionMutation) Status() (r alertsession.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldStatus(ctx context.Context) (v alertsession.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AlertSessionMutation) ResetStatus() {
	m.status = nil
}

// SetStartedAt sets the "started_at" field.
func (m *AlertSessionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *AlertSessionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *AlertSessionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *AlertSessionMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *AlertSessionMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *AlertSessionMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[alertsession.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *AlertSessionMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *AlertSessionMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, alertsession.FieldCompletedAt)
}

// SetErrorMessage sets the "error_message" field.
func (m *AlertSessionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AlertSessionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AlertSessionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[alertsession.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AlertSessionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AlertSessionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, alertsession.FieldErrorMessage)
}

// SetFinalAnalysis sets the "final_analysis" field.
func (m *AlertSessionMutation) SetFinalAnalysis(s string) {
	m.final_analysis = &s
}

// FinalAnalysis returns the value of the "final_analysis" field in the mutation.
func (m *AlertSessionMutation) FinalAnalysis() (r string, exists bool) {
	v := m.final_analysis
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalAnalysis returns the old "final_analysis" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldFinalAnalysis(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalAnalysis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalAnalysis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalAnalysis: %w", err)
	}
	return oldValue.FinalAnalysis, nil
}

// ClearFinalAnalysis clears the value of the "final_analysis" field.
func (m *AlertSessionMutation) ClearFinalAnalysis() {
	m.final_analysis = nil
	m.clearedFields[alertsession.FieldFinalAnalysis] = struct{}{}
}

// FinalAnalysisCleared returns if the "final_analysis" field was cleared in this mutation.
func (m *AlertSessionMutation) FinalAnalysisCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldFinalAnalysis]
	return ok
}

// ResetFinalAnalysis resets all changes to the "final_analysis" field.
func (m *AlertSessionMutation) ResetFinalAnalysis() {
	m.final_analysis = nil
	delete(m.clearedFields, alertsession.FieldFinalAnalysis)
}

// SetExecutiveSummary sets the "executive_summary" field.
func (m *AlertSessionMutation) SetExecutiveSummary(s string) {
	m.executive_summary = &s
}

// ExecutiveSummary returns the value of the "executive_summary" field in the mutation.
func (m *AlertSessionMutation) ExecutiveSummary() (r string, exists bool) {
	v := m.executive_summary
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutiveSummary returns the old "executive_summary" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldExecutiveSummary(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutiveSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutiveSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutiveSummary: %w", err)
	}
	return oldValue.ExecutiveSummary, nil
}

// ClearExecutiveSummary clears the value of the "executive_summary" field.
func (m *AlertSessionMutation) ClearExecutiveSummary() {
	m.executive_summary = nil
	m.clearedFields[alertsession.FieldExecutiveSummary] = struct{}{}
}

// ExecutiveSummaryCleared returns if the "executive_summary" field was cleared in this mutation.
func (m *AlertSessionMutation) ExecutiveSummaryCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldExecutiveSummary]
	return ok
}

// ResetExecutiveSummary resets all changes to the "executive_summary" field.
func (m *AlertSessionMutation) ResetExecutiveSummary() {
	m.executive_summary = nil
	delete(m.clearedFields, alertsession.FieldExecutiveSummary)
}

// SetExecutiveSummaryError sets the "executive_summary_error" field.
func (m *AlertSessionMutation) SetExecutiveSummaryError(s string) {
	m.executive_summary_error = &s
}

// ExecutiveSummaryError returns the value of the "executive_summary_error" field in the mutation.
func (m *AlertSessionMutation) ExecutiveSummaryError() (r string, exists bool) {
	v := m.executive_summary_error
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutiveSummaryError returns the old "executive_summary_error" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldExecutiveSummaryError(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutiveSummaryError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutiveSummaryError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutiveSummaryError: %w", err)
	}
	return oldValue.ExecutiveSummaryError, nil
}

// ClearExecutiveSummaryError clears the value of the "executive_summary_error" field.
func (m *AlertSessionMutation) ClearExecutiveSummaryError() {
	m.executive_summary_error = nil
	m.clearedFields[alertsession.FieldExecutiveSummaryError] = struct{}{}
}

// ExecutiveSummaryErrorCleared returns if the "executive_summary_error" field was cleared in this mutation.
func (m *AlertSessionMutation) ExecutiveSummaryErrorCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldExecutiveSummaryError]
	return ok
}

// ResetExecutiveSummaryError resets all changes to the "executive_summary_error" field.
func (m *AlertSessionMutation) ResetExecutiveSummaryError() {
	m.executive_summary_error = nil
	delete(m.clearedFields, alertsession.FieldExecutiveSummaryError)
}

// SetSessionMetadata sets the "session_metadata" field.
func (m *AlertSessionMutation) SetSessionMetadata(value map[string]interface{}) {
	m.session_metadata = &value
}

// SessionMetadata returns the value of the "session_metadata" field in the mutation.
func (m *AlertSessionMutation) SessionMetadata() (r map[string]interface{}, exists bool) {
	v := m.session_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionMetadata returns the old "session_metadata" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldSessionMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionMetadata: %w", err)
	}
	return oldValue.SessionMetadata, nil
}

// ClearSessionMetadata clears the value of the "session_metadata" field.
func (m *AlertSessionMutation) ClearSessionMetadata() {
	m.session_metadata = nil
	m.clearedFields[alertsession.FieldSessionMetadata] = struct{}{}
}

// SessionMetadataCleared returns if the "session_metadata" field was cleared in this mutation.
func (m *AlertSessionMutation) SessionMetadataCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldSessionMetadata]
	return ok
}

// ResetSessionMetadata resets all changes to the "session_metadata" field.
func (m *AlertSessionMutation) ResetSessionMetadata() {
	m.session_metadata = nil
	delete(m.clearedFields, alertsession.FieldSessionMetadata)
}

// SetAuthor sets the "author" field.
func (m *AlertSessionMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *AlertSessionMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldAuthor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ClearAuthor clears the value of the "author" field.
func (m *AlertSessionMutation) ClearAuthor() {
	m.author = nil
	m.clearedFields[alertsession.FieldAuthor] = struct{}{}
}

// AuthorCleared returns if the "author" field was cleared in this mutation.
func (m *AlertSessionMutation) AuthorCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldAuthor]
	return ok
}

// ResetAuthor resets all changes to the "author" field.
func (m *AlertSessionMutation) ResetAuthor() {
	m.author = nil
	delete(m.clearedFields, alertsession.FieldAuthor)
}

// SetRunbookURL sets the "runbook_url" field.
func (m *AlertSessionMutation) SetRunbookURL(s string) {
	m.runbook_url = &s
}

// RunbookURL returns the value of the "runbook_url" field in the mutation.
func (m *AlertSessionMutation) RunbookURL() (r string, exists bool) {
	v := m.runbook_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRunbookURL returns the old "runbook_url" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldRunbookURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunbookURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunbookURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunbookURL: %w", err)
	}
	return oldValue.RunbookURL, nil
}

// ClearRunbookURL clears the value of the "runbook_url" field.
func (m *AlertSessionMutation) ClearRunbookURL() {
	m.runbook_url = nil
	m.clearedFields[alertsession.FieldRunbookURL] = struct{}{}
}

// RunbookURLCleared returns if the "runbook_url" field was cleared in this mutation.
func (m *AlertSessionMutation) RunbookURLCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldRunbookURL]
	return ok
}

// ResetRunbookURL resets all changes to the "runbook_url" field.
func (m *AlertSessionMutation) ResetRunbookURL() {
	m.runbook_url = nil
	delete(m.clearedFields, alertsession.FieldRunbookURL)
}

// SetMcpSelection sets the "mcp_selection" field.
func (m *AlertSessionMutation) SetMcpSelection(value map[string]interface{}) {
	m.mcp_selection = &value
}

// McpSelection returns the value of the "mcp_selection" field in the mutation.
func (m *AlertSessionMutation) McpSelection() (r map[string]interface{}, exists bool) {
	v := m.mcp_selection
	if v == nil {
		return
	}
	return *v, true
}

// OldMcpSelection returns the old "mcp_selection" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldMcpSelection(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMcpSelection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMcpSelection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMcpSelection: %w", err)
	}
	return oldValue.McpSelection, nil
}

// ClearMcpSelection clears the value of the "mcp_selection" field.
func (m *AlertSessionMutation) ClearMcpSelection() {
	m.mcp_selection = nil
	m.clearedFields[alertsession.FieldMcpSelection] = struct{}{}
}

// McpSelectionCleared returns if the "mcp_selection" field was cleared in this mutation.
func (m *AlertSessionMutation) McpSelectionCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldMcpSelection]
	return ok
}

// ResetMcpSelection resets all changes to the "mcp_selection" field.
func (m *AlertSessionMutation) ResetMcpSelection() {
	m.mcp_selection = nil
	delete(m.clearedFields, alertsession.FieldMcpSelection)
}

// SetChainID sets the "chain_id" field.
func (m *AlertSessionMutation) SetChainID(s string) {
	m.chain_id = &s
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *AlertSessionMutation) ChainID() (r string, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldChainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *AlertSessionMutation) ResetChainID() {
	m.chain_id = nil
}

// SetCurrentStageIndex sets the "current_stage_index" field.
func (m *AlertSessionMutation) SetCurrentStageIndex(i int) {
	m.current_stage_index = &i
	m.addcurrent_stage_index = nil
}

// CurrentStageIndex returns the value of the "current_stage_index" field in the mutation.
func (m *AlertSessionMutation) CurrentStageIndex() (r int, exists bool) {
	v := m.current_stage_index
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentStageIndex returns the old "current_stage_index" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldCurrentStageIndex(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentStageIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentStageIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentStageIndex: %w", err)
	}
	return oldValue.CurrentStageIndex, nil
}

// AddCurrentStageIndex adds i to the "current_stage_index" field.
func (m *AlertSessionMutation) AddCurrentStageIndex(i int) {
	if m.addcurrent_stage_index != nil {
		*m.addcurrent_stage_index += i
	} else {
		m.addcurrent_stage_index = &i
	}
}

// AddedCurrentStageIndex returns the value that was added to the "current_stage_index" field in this mutation.
func (m *AlertSessionMutation) AddedCurrentStageIndex() (r int, exists bool) {
	v := m.addcurrent_stage_index
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrentStageIndex clears the value of the "current_stage_index" field.
func (m *AlertSessionMutation) ClearCurrentStageIndex() {
	m.current_stage_index = nil
	m.addcurrent_stage_index = nil
	m.clearedFields[alertsession.FieldCurrentStageIndex] = struct{}{}
}

// CurrentStageIndexCleared returns if the "current_stage_index" field was cleared in this mutation.
func (m *AlertSessionMutation) CurrentStageIndexCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldCurrentStageIndex]
	return ok
}

// ResetCurrentStageIndex resets all changes to the "current_stage_index" field.
func (m *AlertSessionMutation) ResetCurrentStageIndex() {
	m.current_stage_index = nil
	m.addcurrent_stage_index = nil
	delete(m.clearedFields, alertsession.FieldCurrentStageIndex)
}

// SetCurrentStageID sets the "current_stage_id" field.
func (m *AlertSessionMutation) SetCurrentStageID(s string) {
	m.current_stage_id = &s
}

// CurrentStageID returns the value of the "current_stage_id" field in the mutation.
func (m *AlertSessionMutation) CurrentStageID() (r string, exists bool) {
	v := m.current_stage_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentStageID returns the old "current_stage_id" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldCurrentStageID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentStageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentStageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentStageID: %w", err)
	}
	return oldValue.CurrentStageID, nil
}

// ClearCurrentStageID clears the value of the "current_stage_id" field.
func (m *AlertSessionMutation) ClearCurrentStageID() {
	m.current_stage_id = nil
	m.clearedFields[alertsession.FieldCurrentStageID] = struct{}{}
}

// CurrentStageIDCleared returns if the "current_stage_id" field was cleared in this mutation.
func (m *AlertSessionMutation) CurrentStageIDCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldCurrentStageID]
	return ok
}

// ResetCurrentStageID resets all changes to the "current_stage_id" field.
func (m *AlertSessionMutation) ResetCurrentStageID() {
	m.current_stage_id = nil
	delete(m.clearedFields, alertsession.FieldCurrentStageID)
}

// SetPodID sets the "pod_id" field.
func (m *AlertSessionMutation) SetPodID(s string) {
	m.pod_id = &s
}

// PodID returns the value of the "pod_id" field in the mutation.
func (m *AlertSessionMutation) PodID() (r string, exists bool) {
	v := m.pod_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPodID returns the old "pod_id" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldPodID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPodID: %w", err)
	}
	return oldValue.PodID, nil
}

// ClearPodID clears the value of the "pod_id" field.
func (m *AlertSessionMutation) ClearPodID() {
	m.pod_id = nil
	m.clearedFields[alertsession.FieldPodID] = struct{}{}
}

// PodIDCleared returns if the "pod_id" field was cleared in this mutation.
func (m *AlertSessionMutation) PodIDCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldPodID]
	return ok
}

// ResetPodID resets all changes to the "pod_id" field.
func (m *AlertSessionMutation) ResetPodID() {
	m.pod_id = nil
	delete(m.clearedFields, alertsession.FieldPodID)
}

// SetLastInteractionAt sets the "last_interaction_at" field.
func (m *AlertSessionMutation) SetLastInteractionAt(t time.Time) {
	m.last_interaction_at = &t
}

// LastInteractionAt returns the value of the "last_interaction_at" field in the mutation.
func (m *AlertSessionMutation) LastInteractionAt() (r time.Time, exists bool) {
	v := m.last_interaction_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastInteractionAt returns the old "last_interaction_at" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldLastInteractionAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastInteractionAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastInteractionAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastInteractionAt: %w", err)
	}
	return oldValue.LastInteractionAt, nil
}

// ClearLastInteractionAt clears the value of the "last_interaction_at" field.
func (m *AlertSessionMutation) ClearLastInteractionAt() {
	m.last_interaction_at = nil
	m.clearedFields[alertsession.FieldLastInteractionAt] = struct{}{}
}

// LastInteractionAtCleared returns if the "last_interaction_at" field was cleared in this mutation.
func (m *AlertSessionMutation) LastInteractionAtCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldLastInteractionAt]
	return ok
}

// ResetLastInteractionAt resets all changes to the "last_interaction_at" field.
func (m *AlertSessionMutation) ResetLastInteractionAt() {
	m.last_interaction_at = nil
	delete(m.clearedFields, alertsession.FieldLastInteractionAt)
}

// SetSlackMessageFingerprint sets the "slack_message_fingerprint" field.
func (m *AlertSessionMutation) SetSlackMessageFingerprint(s string) {
	m.slack_message_fingerprint = &s
}

// SlackMessageFingerprint returns the value of the "slack_message_fingerprint" field in the mutation.
func (m *AlertSessionMutation) SlackMessageFingerprint() (r string, exists bool) {
	v := m.slack_message_fingerprint
	if v == nil {
		return
	}
	return *v, true
}

// OldSlackMessageFingerprint returns the old "slack_message_fingerprint" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldSlackMessageFingerprint(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlackMessageFingerprint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlackMessageFingerprint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlackMessageFingerprint: %w", err)
	}
	return oldValue.SlackMessageFingerprint, nil
}

// ClearSlackMessageFingerprint clears the value of the "slack_message_fingerprint" field.
func (m *AlertSessionMutation) ClearSlackMessageFingerprint() {
	m.slack_message_fingerprint = nil
	m.clearedFields[alertsession.FieldSlackMessageFingerprint] = struct{}{}
}

// SlackMessageFingerprintCleared returns if the "slack_message_fingerprint" field was cleared in this mutation.
func (m *AlertSessionMutation) SlackMessageFingerprintCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldSlackMessageFingerprint]
	return ok
}

// ResetSlackMessageFingerprint resets all changes to the "slack_message_fingerprint" field.
func (m *AlertSessionMutation) ResetSlackMessageFingerprint() {
	m.slack_message_fingerprint = nil
	delete(m.clearedFields, alertsession.FieldSlackMessageFingerprint)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AlertSessionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AlertSessionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AlertSession entity.
// If the AlertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertSessionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AlertSessionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[alertsession.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AlertSessionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[alertsession.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AlertSessionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, alertsession.FieldDeletedAt)
}

// AddStageIDs adds the "stages" edge to the Stage entity by ids.
func (m *AlertSessionMutation) AddStageIDs(ids ...string) {
	if m.stages == nil {
		m.stages = make(map[string]struct{})
	}
	for i := range ids {
		m.stages[ids[i]] = struct{}{}
	}
}

// ClearStages clears the "stages" edge to the Stage entity.
func (m *AlertSessionMutation) ClearStages() {
	m.clearedstages = true
}

// StagesCleared reports if the "stages" edge to the Stage entity was cleared.
func (m *AlertSessionMutation) StagesCleared() bool {
	return m.clearedstages
}

// RemoveStageIDs removes the "stages" edge to the Stage entity by IDs.
func (m *AlertSessionMutation) RemoveStageIDs(ids ...string) {
	if m.removedstages == nil {
		m.removedstages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.stages, ids[i])
		m.removedstages[ids[i]] = struct{}{}
	}
}

// RemovedStages returns the removed IDs of the "stages" edge to the Stage entity.
func (m *AlertSessionMutation) RemovedStagesIDs() (ids []string) {
	for id := range m.removedstages {
		ids = append(ids, id)
	}
	return
}

// StagesIDs returns the "stages" edge IDs in the mutation.
func (m *AlertSessionMutation) StagesIDs() (ids []string) {
	for id := range m.stages {
		ids = append(ids, id)
	}
	return
}

// ResetStages resets all changes to the "stages" edge.
func (m *AlertSessionMutation) ResetStages() {
	m.stages = nil
	m.clearedstages = false
	m.removedstages = nil
}

// AddAgentExecutionIDs adds the "agent_executions" edge to the AgentExecution entity by ids.
func (m *AlertSessionMutation) AddAgentExecutionIDs(ids ...string) {
	if m.agent_executions == nil {
		m.agent_executions = make(map[string]struct{})
	}
	for i := range ids {
		m.agent_executions[ids[i]] = struct{}{}
	}
}

// ClearAgentExecutions clears the "agent_executions" edge to the AgentExecution entity.
func (m *AlertSessionMutation) ClearAgentExecutions() {
	m.clearedagent_executions = true
}

// AgentExecutionsCleared reports if the "agent_executions" edge to the AgentExecution entity was cleared.
func (m *AlertSessionMutation) AgentExecutionsCleared() bool {
	return m.clearedagent_executions
}

// RemoveAgentExecutionIDs removes the "agent_executions" edge to the AgentExecution entity by IDs.
func (m *AlertSessionMutation) RemoveAgentExecutionIDs(ids ...string) {
	if m.removedagent_executions == nil {
		m.removedagent_executions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.agent_executions, ids[i])
		m.removedagent_executions[ids[i]] = struct{}{}
	}
}

// RemovedAgentExecutions returns the removed IDs of the "agent_executions" edge to the AgentExecution entity.
func (m *AlertSessionMutation) RemovedAgentExecutionsIDs() (ids []string) {
	for id := range m.removedagent_executions {
		ids = append(ids, id)
	}
	return
}

// AgentExecutionsIDs returns the "agent_executions" edge IDs in the mutation.
func (m *AlertSessionMutation) AgentExecutionsIDs() (ids []string) {
	for id := range m.agent_executions {
		ids = append(ids, id)
	}
	return
}

// ResetAgentExecutions resets all changes to the "agent_executions" edge.
func (m *AlertSessionMutation) ResetAgentExecutions() {
	m.agent_executions = nil
	m.clearedagent_executions = false
	m.removedagent_executions = nil
}

// AddTimelineEventIDs adds the "timeline_events" edge to the TimelineEvent entity by ids.
func (m *AlertSessionMutation) AddTimelineEventIDs(ids ...string) {
	if m.timeline_events == nil {
		m.timeline_events = make(map[string]struct{})
	}
	for i := range ids {
		m.timeline_events[ids[i]] = struct{}{}
	}
}

// ClearTimelineEvents clears the "timeline_events" edge to the TimelineEvent entity.
func (m *AlertSessionMutation) ClearTimelineEvents() {
	m.clearedtimeline_events = true
}

// TimelineEventsCleared reports if the "timeline_events" edge to the TimelineEvent entity was cleared.
func (m *AlertSessionMutation) TimelineEventsCleared() bool {
	return m.clearedtimeline_events
}

// RemoveTimelineEventIDs removes the "timeline_events" edge to the TimelineEvent entity by IDs.
func (m *AlertSessionMutation) RemoveTimelineEventIDs(ids ...string) {
	if m.removedtimeline_events == nil {
		m.removedtimeline_events = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.timeline_events, ids[i])
		m.removedtimeline_events[ids[i]] = struct{}{}
	}
}

// RemovedTimelineEvents returns the removed IDs of the "timeline_events" edge to the TimelineEvent entity.
func (m *AlertSessionMutation) RemovedTimelineEventsIDs() (ids []string) {
	for id := range m.removedtimeline_events {
		ids = append(ids, id)
	}
	return
}

// TimelineEventsIDs returns the "timeline_events" edge IDs in the mutation.
func (m *AlertSessionMutation) TimelineEventsIDs() (ids []string) {
	for id := range m.timeline_events {
		ids = append(ids, id)
	}
	return
}

// ResetTimelineEvents resets all changes to the "timeline_events" edge.
func (m *AlertSessionMutation) ResetTimelineEvents() {
	m.timeline_events = nil
	m.clearedtimeline_events = false
	m.removedtimeline_events = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *AlertSessionMutation) AddMessageIDs(ids ...string) {
	if m.messages == nil {
		m.messages = make(map[string]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *AlertSessionMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *AlertSessionMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *AlertSessionMutation) RemoveMessageIDs(ids ...string) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *AlertSessionMutation) RemovedMessagesIDs() (ids []string) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *AlertSessionMutation) MessagesIDs() (ids []string) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *AlertSessionMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddLlmInteractionIDs adds the "llm_interactions" edge to the LLMInteraction entity by ids.
func (m *AlertSessionMutation) AddLlmInteractionIDs(ids ...string) {
	if m.llm_interactions == nil {
		m.llm_interactions = make(map[string]struct{})
	}
	for i := range ids {
		m.llm_interactions[ids[i]] = struct{}{}
	}
}

// ClearLlmInteractions clears the "llm_interactions" edge to the LLMInteraction entity.
func (m *AlertSessionMutation) ClearLlmInteractions() {
	m.clearedllm_interactions = true
}

// LlmInteractionsCleared reports if the "llm_interactions" edge to the LLMInteraction entity was cleared.
func (m *AlertSessionMutation) LlmInteractionsCleared() bool {
	return m.clearedllm_interactions
}

// RemoveLlmInteractionIDs removes the "llm_interactions" edge to the LLMInteraction entity by IDs.
func (m *AlertSessionMutation) RemoveLlmInteractionIDs(ids ...string) {
	if m.removedllm_interactions == nil {
		m.removedllm_interactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.llm_interactions, ids[i])
		m.removedllm_interactions[ids[i]] = struct{}{}
	}
}

// RemovedLlmInteractions returns the removed IDs of the "llm_interactions" edge to the LLMInteraction entity.
func (m *AlertSessionMutation) RemovedLlmInteractionsIDs() (ids []string) {
	for id := range m.removedllm_interactions {
		ids = append(ids, id)
	}
	return
}

// LlmInteractionsIDs returns the "llm_interactions" edge IDs in the mutation.
func (m *AlertSessionMutation) LlmInteractionsIDs() (ids []string) {
	for id := range m.llm_interactions {
		ids = append(ids, id)
	}
	return
}

// ResetLlmInteractions resets all changes to the "llm_interactions" edge.
func (m *AlertSessionMutation) ResetLlmInteractions() {
	m.llm_interactions = nil
	m.clearedllm_interactions = false
	m.removedllm_interactions = nil
}

// AddMcpInteractionIDs adds the "mcp_interactions" edge to the MCPInteraction entity by ids.
func (m *AlertSessionMutation) AddMcpInteractionIDs(ids ...string) {
	if m.mcp_interactions == nil {
		m.mcp_interactions = make(map[string]struct{})
	}
	for i := range ids {
		m.mcp_interactions[ids[i]] = struct{}{}
	}
}

// ClearMcpInteractions clears the "mcp_interactions" edge to the MCPInteraction entity.
func (m *AlertSessionMutation) ClearMcpInteractions() {
	m.clearedmcp_interactions = true
}

// McpInteractionsCleared reports if the "mcp_interactions" edge to the MCPInteraction entity was cleared.
func (m *AlertSessionMutation) McpInteractionsCleared() bool {
	return m.clearedmcp_interactions
}

// RemoveMcpInteractionIDs removes the "mcp_interactions" edge to the MCPInteraction entity by IDs.
func (m *AlertSessionMutation) RemoveMcpInteractionIDs(ids ...string) {
	if m.removedmcp_interactions == nil {
		m.removedmcp_interactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.mcp_interactions, ids[i])
		m.removedmcp_interactions[ids[i]] = struct{}{}
	}
}

// RemovedMcpInteractions returns the removed IDs of the "mcp_interactions" edge to the MCPInteraction entity.
func (m *AlertSessionMutation) RemovedMcpInteractionsIDs() (ids []string) {
	for id := range m.removedmcp_interactions {
		ids = append(ids, id)
	}
	return
}

// McpInteractionsIDs returns the "mcp_interactions" edge IDs in the mutation.
func (m *AlertSessionMutation) McpInteractionsIDs() (ids []string) {
	for id := range m.mcp_interactions {
		ids = append(ids, id)
	}
	return
}

// ResetMcpInteractions resets all changes to the "mcp_interactions" edge.
func (m *AlertSessionMutation) ResetMcpInteractions() {
	m.mcp_interactions = nil
	m.clearedmcp_interactions = false
	m.removedmcp_interactions = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *AlertSessionMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *AlertSessionMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *AlertSessionMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *AlertSessionMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *AlertSessionMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *AlertSessionMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *AlertSessionMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// SetChatID sets the "chat" edge to the Chat entity by id.
func (m *AlertSessionMutation) SetChatID(id string) {
	m.chat = &id
}

// ClearChat clears the "chat" edge to the Chat entity.
func (m *AlertSessionMutation) ClearChat() {
	m.clearedchat = true
}

// ChatCleared reports if the "chat" edge to the Chat entity was cleared.
func (m *AlertSessionMutation) ChatCleared() bool {
	return m.clearedchat
}

// ChatID returns the "chat" edge ID in the mutation.
func (m *AlertSessionMutation) ChatID() (id string, exists bool) {
	if m.chat != nil {
		return *m.chat, true
	}
	return
}

// ChatIDs returns the "chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChatID instead. It exists only for internal usage by the builders.
func (m *AlertSessionMutation) ChatIDs() (ids []string) {
	if id := m.chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChat resets all changes to the "chat" edge.
func (m *AlertSessionMutation) ResetChat() {
	m.chat = nil
	m.clearedchat = false
}

// Where appends a list predicates to the AlertSessionMutation builder.
func (m *AlertSessionMutation) Where(ps ...predicate.AlertSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlertSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlertSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlertSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlertSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlertSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlertSession).
func (m *AlertSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertSessionMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.alert_data != nil {
		fields = append(fields, alertsession.FieldAlertData)
	}
	if m.agent_type != nil {
		fields = append(fields, alertsession.FieldAgentType)
	}
	if m.alert_type != nil {
		fields = append(fields, alertsession.FieldAlertType)
	}
	if m.status != nil {
		fields = append(fields, alertsession.FieldStatus)
	}
	if m.started_at != nil {
		fields = append(fields, alertsession.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, alertsession.FieldCompletedAt)
	}
	if m.error_message != nil {
		fields = append(fields, alertsession.FieldErrorMessage)
	}
	if m.final_analysis != nil {
		fields = append(fields, alertsession.FieldFinalAnalysis)
	}
	if m.executive_summary != nil {
		fields = append(fields, alertsession.FieldExecutiveSummary)
	}
	if m.executive_summary_error != nil {
		fields = append(fields, alertsession.FieldExecutiveSummaryError)
	}
	if m.session_metadata != nil {
		fields = append(fields, alertsession.FieldSessionMetadata)
	}
	if m.author != nil {
		fields = append(fields, alertsession.FieldAuthor)
	}
	if m.runbook_url != nil {
		fields = append(fields, alertsession.FieldRunbookURL)
	}
	if m.mcp_selection != nil {
		fields = append(fields, alertsession.FieldMcpSelection)
	}
	if m.chain_id != nil {
		fields = append(fields, alertsession.FieldChainID)
	}
	if m.current_stage_index != nil {
		fields = append(fields, alertsession.FieldCurrentStageIndex)
	}
	if m.current_stage_id != nil {
		fields = append(fields, alertsession.FieldCurrentStageID)
	}
	if m.pod_id != nil {
		fields = append(fields, alertsession.FieldPodID)
	}
	if m.last_interaction_at != nil {
		fields = append(fields, alertsession.FieldLastInteractionAt)
	}
	if m.slack_message_fingerprint != nil {
		fields = append(fields, alertsession.FieldSlackMessageFingerprint)
	}
	if m.deleted_at != nil {
		fields = append(fields, alertsession.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alertsession.FieldAlertData:
		return m.AlertData()
	case alertsession.FieldAgentType:
		return m.AgentType()
	case alertsession.FieldAlertType:
		return m.AlertType()
	case alertsession.FieldStatus:
		return m.Status()
	case alertsession.FieldStartedAt:
		return m.StartedAt()
	case alertsession.FieldCompletedAt:
		return m.CompletedAt()
	case alertsession.FieldErrorMessage:
		return m.ErrorMessage()
	case alertsession.FieldFinalAnalysis:
		return m.FinalAnalysis()
	case alertsession.FieldExecutiveSummary:
		return m.ExecutiveSummary()
	case alertsession.FieldExecutiveSummaryError:
		return m.ExecutiveSummaryError()
	case alertsession.FieldSessionMetadata:
		return m.SessionMetadata()
	case alertsession.FieldAuthor:
		return m.Author()
	case alertsession.FieldRunbookURL:
		return m.RunbookURL()
	case alertsession.FieldMcpSelection:
		return m.McpSelection()
	case alertsession.FieldChainID:
		return m.ChainID()
	case alertsession.FieldCurrentStageIndex:
		return m.CurrentStageIndex()
	case alertsession.FieldCurrentStageID:
		return m.CurrentStageID()
	case alertsession.FieldPodID:
		return m.PodID()
	case alertsession.FieldLastInteractionAt:
		return m.LastInteractionAt()
	case alertsession.FieldSlackMessageFingerprint:
		return m.SlackMessageFingerprint()
	case alertsession.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alertsession.FieldAlertData:
		return m.OldAlertData(ctx)
	case alertsession.FieldAgentType:
		return m.OldAgentType(ctx)
	case alertsession.FieldAlertType:
		return m.OldAlertType(ctx)
	case alertsession.FieldStatus:
		return m.OldStatus(ctx)
	case alertsession.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case alertsession.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case alertsession.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case alertsession.FieldFinalAnalysis:
		return m.OldFinalAnalysis(ctx)
	case alertsession.FieldExecutiveSummary:
		return m.OldExecutiveSummary(ctx)
	case alertsession.FieldExecutiveSummaryError:
		return m.OldExecutiveSummaryError(ctx)
	case alertsession.FieldSessionMetadata:
		return m.OldSessionMetadata(ctx)
	case alertsession.FieldAuthor:
		return m.OldAuthor(ctx)
	case alertsession.FieldRunbookURL:
		return m.OldRunbookURL(ctx)
	case alertsession.FieldMcpSelection:
		return m.OldMcpSelection(ctx)
	case alertsession.FieldChainID:
		return m.OldChainID(ctx)
	case alertsession.FieldCurrentStageIndex:
		return m.OldCurrentStageIndex(ctx)
	case alertsession.FieldCurrentStageID:
		return m.OldCurrentStageID(ctx)
	case alertsession.FieldPodID:
		return m.OldPodID(ctx)
	case alertsession.FieldLastInteractionAt:
		return m.OldLastInteractionAt(ctx)
	case alertsession.FieldSlackMessageFingerprint:
		return m.OldSlackMessageFingerprint(ctx)
	case alertsession.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AlertSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alertsession.FieldAlertData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertData(v)
		return nil
	case alertsession.FieldAgentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentType(v)
		return nil
	case alertsession.FieldAlertType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlertType(v)
		return nil
	case alertsession.FieldStatus:
		v, ok := value.(alertsession.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case alertsession.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case alertsession.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case alertsession.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case alertsession.FieldFinalAnalysis:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalAnalysis(v)
		return nil
	case alertsession.FieldExecutiveSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutiveSummary(v)
		return nil
	case alertsession.FieldExecutiveSummaryError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutiveSummaryError(v)
		return nil
	case alertsession.FieldSessionMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionMetadata(v)
		return nil
	case alertsession.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case alertsession.FieldRunbookURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunbookURL(v)
		return nil
	case alertsession.FieldMcpSelection:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMcpSelection(v)
		return nil
	case alertsession.FieldChainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case alertsession.FieldCurrentStageIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentStageIndex(v)
		return nil
	case alertsession.FieldCurrentStageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentStageID(v)
		return nil
	case alertsession.FieldPodID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPodID(v)
		return nil
	case alertsession.FieldLastInteractionAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastInteractionAt(v)
		return nil
	case alertsession.FieldSlackMessageFingerprint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlackMessageFingerprint(v)
		return nil
	case alertsession.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AlertSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertSessionMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_stage_index != nil {
		fields = append(fields, alertsession.FieldCurrentStageIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alertsession.FieldCurrentStageIndex:
		return m.AddedCurrentStageIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alertsession.FieldCurrentStageIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentStageIndex(v)
		return nil
	}
	return fmt.Errorf("unknown AlertSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertSessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alertsession.FieldAlertType) {
		fields = append(fields, alertsession.FieldAlertType)
	}
	if m.FieldCleared(alertsession.FieldCompletedAt) {
		fields = append(fields, alertsession.FieldCompletedAt)
	}
	if m.FieldCleared(alertsession.FieldErrorMessage) {
		fields = append(fields, alertsession.FieldErrorMessage)
	}
	if m.FieldCleared(alertsession.FieldFinalAnalysis) {
		fields = append(fields, alertsession.FieldFinalAnalysis)
	}
	if m.FieldCleared(alertsession.FieldExecutiveSummary) {
		fields = append(fields, alertsession.FieldExecutiveSummary)
	}
	if m.FieldCleared(alertsession.FieldExecutiveSummaryError) {
		fields = append(fields, alertsession.FieldExecutiveSummaryError)
	}
	if m.FieldCleared(alertsession.FieldSessionMetadata) {
		fields = append(fields, alertsession.FieldSessionMetadata)
	}
	if m.FieldCleared(alertsession.FieldAuthor) {
		fields = append(fields, alertsession.FieldAuthor)
	}
	if m.FieldCleared(alertsession.FieldRunbookURL) {
		fields = append(fields, alertsession.FieldRunbookURL)
	}
	if m.FieldCleared(alertsession.FieldMcpSelection) {
		fields = append(fields, alertsession.FieldMcpSelection)
	}
	if m.FieldCleared(alertsession.FieldCurrentStageIndex) {
		fields = append(fields, alertsession.FieldCurrentStageIndex)
	}
	if m.FieldCleared(alertsession.FieldCurrentStageID) {
		fields = append(fields, alertsession.FieldCurrentStageID)
	}
	if m.FieldCleared(alertsession.FieldPodID) {
		fields = append(fields, alertsession.FieldPodID)
	}
	if m.FieldCleared(alertsession.FieldLastInteractionAt) {
		fields = append(fields, alertsession.FieldLastInteractionAt)
	}
	if m.FieldCleared(alertsession.FieldSlackMessageFingerprint) {
		fields = append(fields, alertsession.FieldSlackMessageFingerprint)
	}
	if m.FieldCleared(alertsession.FieldDeletedAt) {
		fields = append(fields, alertsession.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertSessionMutation) ClearField(name string) error {
	switch name {
	case alertsession.FieldAlertType:
		m.ClearAlertType()
		return nil
	case alertsession.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case alertsession.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case alertsession.FieldFinalAnalysis:
		m.ClearFinalAnalysis()
		return nil
	case alertsession.FieldExecutiveSummary:
		m.ClearExecutiveSummary()
		return nil
	case alertsession.FieldExecutiveSummaryError:
		m.ClearExecutiveSummaryError()
		return nil
	case alertsession.FieldSessionMetadata:
		m.ClearSessionMetadata()
		return nil
	case alertsession.FieldAuthor:
		m.ClearAuthor()
		return nil
	case alertsession.FieldRunbookURL:
		m.ClearRunbookURL()
		return nil
	case alertsession.FieldMcpSelection:
		m.ClearMcpSelection()
		return nil
	case alertsession.FieldCurrentStageIndex:
		m.ClearCurrentStageIndex()
		return nil
	case alertsession.FieldCurrentStageID:
		m.ClearCurrentStageID()
		return nil
	case alertsession.FieldPodID:
		m.ClearPodID()
		return nil
	case alertsession.FieldLastInteractionAt:
		m.ClearLastInteractionAt()
		return nil
	case alertsession.FieldSlackMessageFingerprint:
		m.ClearSlackMessageFingerprint()
		return nil
	case alertsession.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertSessionMutation) ResetField(name string) error {
	switch name {
	case alertsession.FieldAlertData:
		m.ResetAlertData()
		return nil
	case alertsession.FieldAgentType:
		m.ResetAgentType()
		return nil
	case alertsession.FieldAlertType:
		m.ResetAlertType()
		return nil
	case alertsession.FieldStatus:
		m.ResetStatus()
		return nil
	case alertsession.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case alertsession.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case alertsession.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case alertsession.FieldFinalAnalysis:
		m.ResetFinalAnalysis()
		return nil
	case alertsession.FieldExecutiveSummary:
		m.ResetExecutiveSummary()
		return nil
	case alertsession.FieldExecutiveSummaryError:
		m.ResetExecutiveSummaryError()
		return nil
	case alertsession.FieldSessionMetadata:
		m.ResetSessionMetadata()
		return nil
	case alertsession.FieldAuthor:
		m.ResetAuthor()
		return nil
	case alertsession.FieldRunbookURL:
		m.ResetRunbookURL()
		return nil
	case alertsession.FieldMcpSelection:
		m.ResetMcpSelection()
		return nil
	case alertsession.FieldChainID:
		m.ResetChainID()
		return nil
	case alertsession.FieldCurrentStageIndex:
		m.ResetCurrentStageIndex()
		return nil
	case alertsession.FieldCurrentStageID:
		m.ResetCurrentStageID()
		return nil
	case alertsession.FieldPodID:
		m.ResetPodID()
		return nil
	case alertsession.FieldLastInteractionAt:
		m.ResetLastInteractionAt()
		return nil
	case alertsession.FieldSlackMessageFingerprint:
		m.ResetSlackMessageFingerprint()
		return nil
	case alertsession.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown AlertSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.stages != nil {
		edges = append(edges, alertsession.EdgeStages)
	}
	if m.agent_executions != nil {
		edges = append(edges, alertsession.EdgeAgentExecutions)
	}
	if m.timeline_events != nil {
		edges = append(edges, alertsession.EdgeTimelineEvents)
	}
	if m.messages != nil {
		edges = append(edges, alertsession.EdgeMessages)
	}
	if m.llm_interactions != nil {
		edges = append(edges, alertsession.EdgeLlmInteractions)
	}
	if m.mcp_interactions != nil {
		edges = append(edges, alertsession.EdgeMcpInteractions)
	}
	if m.events != nil {
		edges = append(edges, alertsession.EdgeEvents)
	}
	if m.chat != nil {
		edges = append(edges, alertsession.EdgeChat)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alertsession.EdgeStages:
		ids := make([]ent.Value, 0, len(m.stages))
		for id := range m.stages {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeAgentExecutions:
		ids := make([]ent.Value, 0, len(m.agent_executions))
		for id := range m.agent_executions {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeTimelineEvents:
		ids := make([]ent.Value, 0, len(m.timeline_events))
		for id := range m.timeline_events {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeLlmInteractions:
		ids := make([]ent.Value, 0, len(m.llm_interactions))
		for id := range m.llm_interactions {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeMcpInteractions:
		ids := make([]ent.Value, 0, len(m.mcp_interactions))
		for id := range m.mcp_interactions {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeChat:
		if id := m.chat; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedstages != nil {
		edges = append(edges, alertsession.EdgeStages)
	}
	if m.removedagent_executions != nil {
		edges = append(edges, alertsession.EdgeAgentExecutions)
	}
	if m.removedtimeline_events != nil {
		edges = append(edges, alertsession.EdgeTimelineEvents)
	}
	if m.removedmessages != nil {
		edges = append(edges, alertsession.EdgeMessages)
	}
	if m.removedllm_interactions != nil {
		edges = append(edges, alertsession.EdgeLlmInteractions)
	}
	if m.removedmcp_interactions != nil {
		edges = append(edges, alertsession.EdgeMcpInteractions)
	}
	if m.removedevents != nil {
		edges = append(edges, alertsession.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case alertsession.EdgeStages:
		ids := make([]ent.Value, 0, len(m.removedstages))
		for id := range m.removedstages {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeAgentExecutions:
		ids := make([]ent.Value, 0, len(m.removedagent_executions))
		for id := range m.removedagent_executions {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeTimelineEvents:
		ids := make([]ent.Value, 0, len(m.removedtimeline_events))
		for id := range m.removedtimeline_events {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeLlmInteractions:
		ids := make([]ent.Value, 0, len(m.removedllm_interactions))
		for id := range m.removedllm_interactions {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeMcpInteractions:
		ids := make([]ent.Value, 0, len(m.removedmcp_interactions))
		for id := range m.removedmcp_interactions {
			ids = append(ids, id)
		}
		return ids
	case alertsession.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedstages {
		edges = append(edges, alertsession.EdgeStages)
	}
	if m.clearedagent_executions {
		edges = append(edges, alertsession.EdgeAgentExecutions)
	}
	if m.clearedtimeline_events {
		edges = append(edges, alertsession.EdgeTimelineEvents)
	}
	if m.clearedmessages {
		edges = append(edges, alertsession.EdgeMessages)
	}
	if m.clearedllm_interactions {
		edges = append(edges, alertsession.EdgeLlmInteractions)
	}
	if m.clearedmcp_interactions {
		edges = append(edges, alertsession.EdgeMcpInteractions)
	}
	if m.clearedevents {
		edges = append(edges, alertsession.EdgeEvents)
	}
	if m.clearedchat {
		edges = append(edges, alertsession.EdgeChat)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case alertsession.EdgeStages:
		return m.clearedstages
	case alertsession.EdgeAgentExecutions:
		return m.clearedagent_executions
	case alertsession.EdgeTimelineEvents:
		return m.clearedtimeline_events
	case alertsession.EdgeMessages:
		return m.clearedmessages
	case alertsession.EdgeLlmInteractions:
		return m.clearedllm_interactions
	case alertsession.EdgeMcpInteractions:
		return m.clearedmcp_interactions
	case alertsession.EdgeEvents:
		return m.clearedevents
	case alertsession.EdgeChat:
		return m.clearedchat
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertSessionMutation) ClearEdge(name string) error {
	switch name {
	case alertsession.EdgeChat:
		m.ClearChat()
		return nil
	}
	return fmt.Errorf("unknown AlertSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertSessionMutation) ResetEdge(name string) error {
	switch name {
	case alertsession.EdgeStages:
		m.ResetStages()
		return nil
	case alertsession.EdgeAgentExecutions:
		m.ResetAgentExecutions()
		return nil
	case alertsession.EdgeTimelineEvents:
		m.ResetTimelineEvents()
		return nil
	case alertsession.EdgeMessages:
		m.ResetMessages()
		return nil
	case alertsession.EdgeLlmInteractions:
		m.ResetLlmInteractions()
		return nil
	case alertsession.EdgeMcpInteractions:
		m.ResetMcpInteractions()
		return nil
	case alertsession.EdgeEvents:
		m.ResetEvents()
		return nil
	case alertsession.EdgeChat:
		m.ResetChat()
		return nil
	}
	return fmt.Errorf("unknown AlertSession edge %s", name)
}

// ChatMutation represents an operation that mutates the Chat nodes in the graph.
type ChatMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	created_by           *string
	chain_id             *string
	pod_id               *string
	last_interaction_at  *time.Time
	clearedFields        map[string]struct{}
	session              *string
	clearedsession       bool
	user_messages        map[string]struct{}
	removeduser_messages map[string]struct{}
	cleareduser_messages bool
	stages               map[string]struct{}
	removedstages        map[string]struct{}
	clearedstages        bool
	done                 bool
	oldValue             func(context.Context) (*Chat, error)
	predicates           []predicate.Chat
}

var _ ent.Mutation = (*ChatMutation)(nil)

// chatOption allows management of the mutation configuration using functional options.
type chatOption func(*ChatMutation)

// newChatMutation creates new mutation for the Chat entity.
func newChatMutation(c config, op Op, opts ...chatOption) *ChatMutation {
	m := &ChatMutation{
		config:        c,
		op:            op,
		typ:           TypeChat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChatID sets the ID field of the mutation.
func withChatID(id string) chatOption {
	return func(m *ChatMutation) {
		var (
			err   error
			once  sync.Once
			value *Chat
		)
		m.oldValue = func(ctx context.Context) (*Chat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChat sets the old Chat of the mutation.
func withChat(node *Chat) chatOption {
	return func(m *ChatMutation) {
		m.oldValue = func(context.Context) (*Chat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Chat entities.
func (m *ChatMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChatMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChatMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *ChatMutation) SetSessionID(s string) {
	m.session = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *ChatMutation) SessionID() (r string, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *ChatMutation) ResetSessionID() {
	m.session = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ChatMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ChatMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldCreatedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ChatMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[chat.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ChatMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[chat.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ChatMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, chat.FieldCreatedBy)
}

// SetChainID sets the "chain_id" field.
func (m *ChatMutation) SetChainID(s string) {
	m.chain_id = &s
}

// ChainID returns the value of the "chain_id" field in the mutation.
func (m *ChatMutation) ChainID() (r string, exists bool) {
	v := m.chain_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainID returns the old "chain_id" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldChainID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainID: %w", err)
	}
	return oldValue.ChainID, nil
}

// ResetChainID resets all changes to the "chain_id" field.
func (m *ChatMutation) ResetChainID() {
	m.chain_id = nil
}

// SetPodID sets the "pod_id" field.
func (m *ChatMutation) SetPodID(s string) {
	m.pod_id = &s
}

// PodID returns the value of the "pod_id" field in the mutation.
func (m *ChatMutation) PodID() (r string, exists bool) {
	v := m.pod_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPodID returns the old "pod_id" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldPodID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPodID: %w", err)
	}
	return oldValue.PodID, nil
}

// ClearPodID clears the value of the "pod_id" field.
func (m *ChatMutation) ClearPodID() {
	m.pod_id = nil
	m.clearedFields[chat.FieldPodID] = struct{}{}
}

// PodIDCleared returns if the "pod_id" field was cleared in this mutation.
func (m *ChatMutation) PodIDCleared() bool {
	_, ok := m.clearedFields[chat.FieldPodID]
	return ok
}

// ResetPodID resets all changes to the "pod_id" field.
func (m *ChatMutation) ResetPodID() {
	m.pod_id = nil
	delete(m.clearedFields, chat.FieldPodID)
}

// SetLastInteractionAt sets the "last_interaction_at" field.
func (m *ChatMutation) SetLastInteractionAt(t time.Time) {
	m.last_interaction_at = &t
}

// LastInteractionAt returns the value of the "last_interaction_at" field in the mutation.
func (m *ChatMutation) LastInteractionAt() (r time.Time, exists bool) {
	v := m.last_interaction_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastInteractionAt returns the old "last_interaction_at" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldLastInteractionAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastInteractionAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastInteractionAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastInteractionAt: %w", err)
	}
	return oldValue.LastInteractionAt, nil
}

// ClearLastInteractionAt clears the value of the "last_interaction_at" field.
func (m *ChatMutation) ClearLastInteractionAt() {
	m.last_interaction_at = nil
	m.clearedFields[chat.FieldLastInteractionAt] = struct{}{}
}

// LastInteractionAtCleared returns if the "last_interaction_at" field was cleared in this mutation.
func (m *ChatMutation) LastInteractionAtCleared() bool {
	_, ok := m.clearedFields[chat.FieldLastInteractionAt]
	return ok
}

// ResetLastInteractionAt resets all changes to the "last_interaction_at" field.
func (m *ChatMutation) ResetLastInteractionAt() {
	m.last_interaction_at = nil
	delete(m.clearedFields, chat.FieldLastInteractionAt)
}

// ClearSession clears the "session" edge to the AlertSession entity.
func (m *ChatMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[chat.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the AlertSession entity was cleared.
func (m *ChatMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *ChatMutation) SessionIDs() (ids []string) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *ChatMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// AddUserMessageIDs adds the "user_messages" edge to the ChatUserMessage entity by ids.
func (m *ChatMutation) AddUserMessageIDs(ids ...string) {
	if m.user_messages == nil {
		m.user_messages = make(map[string]struct{})
	}
	for i := range ids {
		m.user_messages[ids[i]] = struct{}{}
	}
}

// ClearUserMessages clears the "user_messages" edge to the ChatUserMessage entity.
func (m *ChatMutation) ClearUserMessages() {
	m.cleareduser_messages = true
}

// UserMessagesCleared reports if the "user_messages" edge to the ChatUserMessage entity was cleared.
func (m *ChatMutation) UserMessagesCleared() bool {
	return m.cleareduser_messages
}

// RemoveUserMessageIDs removes the "user_messages" edge to the ChatUserMessage entity by IDs.
func (m *ChatMutation) RemoveUserMessageIDs(ids ...string) {
	if m.removeduser_messages == nil {
		m.removeduser_messages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_messages, ids[i])
		m.removeduser_messages[ids[i]] = struct{}{}
	}
}

// RemovedUserMessages returns the removed IDs of the "user_messages" edge to the ChatUserMessage entity.
func (m *ChatMutation) RemovedUserMessagesIDs() (ids []string) {
	for id := range m.removeduser_messages {
		ids = append(ids, id)
	}
	return
}

// UserMessagesIDs returns the "user_messages" edge IDs in the mutation.
func (m *ChatMutation) UserMessagesIDs() (ids []string) {
	for id := range m.user_messages {
		ids = append(ids, id)
	}
	return
}

// ResetUserMessages resets all changes to the "user_messages" edge.
func (m *ChatMutation) ResetUserMessages() {
	m.user_messages = nil
	m.cleareduser_messages = false
	m.removeduser_messages = nil
}

// AddStageIDs adds the "stages" edge to the Stage entity by ids.
func (m *ChatMutation) AddStageIDs(ids ...string) {
	if m.stages == nil {
		m.stages = make(map[string]struct{})
	}
	for i := range ids {
		m.stages[ids[i]] = struct{}{}
	}
}

// ClearStages clears the "stages" edge to the Stage entity.
func (m *ChatMutation) ClearStages() {
	m.clearedstages = true
}

// StagesCleared reports if the "stages" edge to the Stage entity was cleared.
func (m *ChatMutation) StagesCleared() bool {
	return m.clearedstages
}

// RemoveStageIDs removes the "stages" edge to the Stage entity by IDs.
func (m *ChatMutation) RemoveStageIDs(ids ...string) {
	if m.removedstages == nil {
		m.removedstages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.stages, ids[i])
		m.removedstages[ids[i]] = struct{}{}
	}
}

// RemovedStages returns the removed IDs of the "stages" edge to the Stage entity.
func (m *ChatMutation) RemovedStagesIDs() (ids []string) {
	for id := range m.removedstages {
		ids = append(ids, id)
	}
	return
}

// StagesIDs returns the "stages" edge IDs in the mutation.
func (m *ChatMutation) StagesIDs() (ids []string) {
	for id := range m.stages {
		ids = append(ids, id)
	}
	return
}

// ResetStages resets all changes to the "stages" edge.
func (m *ChatMutation) ResetStages() {
	m.stages = nil
	m.clearedstages = false
	m.removedstages = nil
}

// Where appends a list predicates to the ChatMutation builder.
func (m *ChatMutation) Where(ps ...predicate.Chat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chat).
func (m *ChatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChatMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.session != nil {
		fields = append(fields, chat.FieldSessionID)
	}
	if m.created_at != nil {
		fields = append(fields, chat.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, chat.FieldCreatedBy)
	}
	if m.chain_id != nil {
		fields = append(fields, chat.FieldChainID)
	}
	if m.pod_id != nil {
		fields = append(fields, chat.FieldPodID)
	}
	if m.last_interaction_at != nil {
		fields = append(fields, chat.FieldLastInteractionAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chat.FieldSessionID:
		return m.SessionID()
	case chat.FieldCreatedAt:
		return m.CreatedAt()
	case chat.FieldCreatedBy:
		return m.CreatedBy()
	case chat.FieldChainID:
		return m.ChainID()
	case chat.FieldPodID:
		return m.PodID()
	case chat.FieldLastInteractionAt:
		return m.LastInteractionAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chat.FieldSessionID:
		return m.OldSessionID(ctx)
	case chat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chat.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case chat.FieldChainID:
		return m.OldChainID(ctx)
	case chat.FieldPodID:
		return m.OldPodID(ctx)
	case chat.FieldLastInteractionAt:
		return m.OldLastInteractionAt(ctx)
	}
	return nil, fmt.Errorf("unknown Chat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chat.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case chat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chat.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case chat.FieldChainID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainID(v)
		return nil
	case chat.FieldPodID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPodID(v)
		return nil
	case chat.FieldLastInteractionAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastInteractionAt(v)
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Chat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chat.FieldCreatedBy) {
		fields = append(fields, chat.FieldCreatedBy)
	}
	if m.FieldCleared(chat.FieldPodID) {
		fields = append(fields, chat.FieldPodID)
	}
	if m.FieldCleared(chat.FieldLastInteractionAt) {
		fields = append(fields, chat.FieldLastInteractionAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChatMutation) ClearField(name string) error {
	switch name {
	case chat.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case chat.FieldPodID:
		m.ClearPodID()
		return nil
	case chat.FieldLastInteractionAt:
		m.ClearLastInteractionAt()
		return nil
	}
	return fmt.Errorf("unknown Chat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChatMutation) ResetField(name string) error {
	switch name {
	case chat.FieldSessionID:
		m.ResetSessionID()
		return nil
	case chat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chat.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case chat.FieldChainID:
		m.ResetChainID()
		return nil
	case chat.FieldPodID:
		m.ResetPodID()
		return nil
	case chat.FieldLastInteractionAt:
		m.ResetLastInteractionAt()
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChatMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.session != nil {
		edges = append(edges, chat.EdgeSession)
	}
	if m.user_messages != nil {
		edges = append(edges, chat.EdgeUserMessages)
	}
	if m.stages != nil {
		edges = append(edges, chat.EdgeStages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chat.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case chat.EdgeUserMessages:
		ids := make([]ent.Value, 0, len(m.user_messages))
		for id := range m.user_messages {
			ids = append(ids, id)
		}
		return ids
	case chat.EdgeStages:
		ids := make([]ent.Value, 0, len(m.stages))
		for id := range m.stages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser_messages != nil {
		edges = append(edges, chat.EdgeUserMessages)
	}
	if m.removedstages != nil {
		edges = append(edges, chat.EdgeStages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case chat.EdgeUserMessages:
		ids := make([]ent.Value, 0, len(m.removeduser_messages))
		for id := range m.removeduser_messages {
			ids = append(ids, id)
		}
		return ids
	case chat.EdgeStages:
		ids := make([]ent.Value, 0, len(m.removedstages))
		for id := range m.removedstages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsession {
		edges = append(edges, chat.EdgeSession)
	}
	if m.cleareduser_messages {
		edges = append(edges, chat.EdgeUserMessages)
	}
	if m.clearedstages {
		edges = append(edges, chat.EdgeStages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChatMutation) EdgeCleared(name string) bool {
	switch name {
	case chat.EdgeSession:
		return m.clearedsession
	case chat.EdgeUserMessages:
		return m.cleareduser_messages
	case chat.EdgeStages:
		return m.clearedstages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChatMutation) ClearEdge(name string) error {
	switch name {
	case chat.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown Chat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChatMutation) ResetEdge(name string) error {
	switch name {
	case chat.EdgeSession:
		m.ResetSession()
		return nil
	case chat.EdgeUserMessages:
		m.ResetUserMessages()
		return nil
	case chat.EdgeStages:
		m.ResetStages()
		return nil
	}
	return fmt.Errorf("unknown Chat edge %s", name)
}

// ChatUserMessageMutation represents an operation that mutates the ChatUserMessage nodes in the graph.
type ChatUserMessageMutation struct {
	config
	op            Op
	typ           string
	id            *string
	content       *string
	author        *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	chat          *string
	clearedchat   bool
	stage         *string
	clearedstage  bool
	done          bool
	oldValue      func(context.Context) (*ChatUserMessage, error)
	predicates    []predicate.ChatUserMessage
}

var _ ent.Mutation = (*ChatUserMessageMutation)(nil)

// chatusermessageOption allows management of the mutation configuration using functional options.
type chatusermessageOption func(*ChatUserMessageMutation)

// newChatUserMessageMutation creates new mutation for the ChatUserMessage entity.
func newChatUserMessageMutation(c config, op Op, opts ...chatusermessageOption) *ChatUserMessageMutation {
	m := &ChatUserMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeChatUserMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChatUserMessageID sets the ID field of the mutation.
func withChatUserMessageID(id string) chatusermessageOption {
	return func(m *ChatUserMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *ChatUserMessage
		)
		m.oldValue = func(ctx context.Context) (*ChatUserMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChatUserMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChatUserMessage sets the old ChatUserMessage of the mutation.
func withChatUserMessage(node *ChatUserMessage) chatusermessageOption {
	return func(m *ChatUserMessageMutation) {
		m.oldValue = func(context.Context) (*ChatUserMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChatUserMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChatUserMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChatUserMessage entities.
func (m *ChatUserMessageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChatUserMessageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChatUserMessageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChatUserMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChatID sets the "chat_id" field.
func (m *ChatUserMessageMutation) SetChatID(s string) {
	m.chat = &s
}

// ChatID returns the value of the "chat_id" field in the mutation.
func (m *ChatUserMessageMutation) ChatID() (r string, exists bool) {
	v := m.chat
	if v == nil {
		return
	}
	return *v, true
}

// OldChatID returns the old "chat_id" field's value of the ChatUserMessage entity.
// If the ChatUserMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatUserMessageMutation) OldChatID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatID: %w", err)
	}
	return oldValue.ChatID, nil
}

// ResetChatID resets all changes to the "chat_id" field.
func (m *ChatUserMessageMutation) ResetChatID() {
	m.chat = nil
}

// SetContent sets the "content" field.
func (m *ChatUserMessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ChatUserMessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the ChatUserMessage entity.
// If the ChatUserMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatUserMessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ChatUserMessageMutation) ResetContent() {
	m.content = nil
}

// SetAuthor sets the "author" field.
func (m *ChatUserMessageMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *ChatUserMessageMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the ChatUserMessage entity.
// If the ChatUserMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatUserMessageMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *ChatUserMessageMutation) ResetAuthor() {
	m.author = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChatUserMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChatUserMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChatUserMessage entity.
// If the ChatUserMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatUserMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChatUserMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearChat clears the "chat" edge to the Chat entity.
func (m *ChatUserMessageMutation) ClearChat() {
	m.clearedchat = true
	m.clearedFields[chatusermessage.FieldChatID] = struct{}{}
}

// ChatCleared reports if the "chat" edge to the Chat entity was cleared.
func (m *ChatUserMessageMutation) ChatCleared() bool {
	return m.clearedchat
}

// ChatIDs returns the "chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChatID instead. It exists only for internal usage by the builders.
func (m *ChatUserMessageMutation) ChatIDs() (ids []string) {
	if id := m.chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChat resets all changes to the "chat" edge.
func (m *ChatUserMessageMutation) ResetChat() {
	m.chat = nil
	m.clearedchat = false
}

// SetStageID sets the "stage" edge to the Stage entity by id.
func (m *ChatUserMessageMutation) SetStageID(id string) {
	m.stage = &id
}

// ClearStage clears the "stage" edge to the Stage entity.
func (m *ChatUserMessageMutation) ClearStage() {
	m.clearedstage = true
}

// StageCleared reports if the "stage" edge to the Stage entity was cleared.
func (m *ChatUserMessageMutation) StageCleared() bool {
	return m.clearedstage
}

// StageID returns the "stage" edge ID in the mutation.
func (m *ChatUserMessageMutation) StageID() (id string, exists bool) {
	if m.stage != nil {
		return *m.stage, true
	}
	return
}

// StageIDs returns the "stage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageID instead. It exists only for internal usage by the builders.
func (m *ChatUserMessageMutation) StageIDs() (ids []string) {
	if id := m.stage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStage resets all changes to the "stage" edge.
func (m *ChatUserMessageMutation) ResetStage() {
	m.stage = nil
	m.clearedstage = false
}

// Where appends a list predicates to the ChatUserMessageMutation builder.
func (m *ChatUserMessageMutation) Where(ps ...predicate.ChatUserMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChatUserMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChatUserMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChatUserMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChatUserMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChatUserMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChatUserMessage).
func (m *ChatUserMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChatUserMessageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.chat != nil {
		fields = append(fields, chatusermessage.FieldChatID)
	}
	if m.content != nil {
		fields = append(fields, chatusermessage.FieldContent)
	}
	if m.author != nil {
		fields = append(fields, chatusermessage.FieldAuthor)
	}
	if m.created_at != nil {
		fields = append(fields, chatusermessage.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChatUserMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chatusermessage.FieldChatID:
		return m.ChatID()
	case chatusermessage.FieldContent:
		return m.Content()
	case chatusermessage.FieldAuthor:
		return m.Author()
	case chatusermessage.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChatUserMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chatusermessage.FieldChatID:
		return m.OldChatID(ctx)
	case chatusermessage.FieldContent:
		return m.OldContent(ctx)
	case chatusermessage.FieldAuthor:
		return m.OldAuthor(ctx)
	case chatusermessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ChatUserMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatUserMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chatusermessage.FieldChatID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatID(v)
		return nil
	case chatusermessage.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case chatusermessage.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case chatusermessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ChatUserMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChatUserMessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChatUserMessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatUserMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChatUserMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChatUserMessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChatUserMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChatUserMessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChatUserMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChatUserMessageMutation) ResetField(name string) error {
	switch name {
	case chatusermessage.FieldChatID:
		m.ResetChatID()
		return nil
	case chatusermessage.FieldContent:
		m.ResetContent()
		return nil
	case chatusermessage.FieldAuthor:
		m.ResetAuthor()
		return nil
	case chatusermessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ChatUserMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChatUserMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.chat != nil {
		edges = append(edges, chatusermessage.EdgeChat)
	}
	if m.stage != nil {
		edges = append(edges, chatusermessage.EdgeStage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChatUserMessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chatusermessage.EdgeChat:
		if id := m.chat; id != nil {
			return []ent.Value{*id}
		}
	case chatusermessage.EdgeStage:
		if id := m.stage; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChatUserMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChatUserMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChatUserMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchat {
		edges = append(edges, chatusermessage.EdgeChat)
	}
	if m.clearedstage {
		edges = append(edges, chatusermessage.EdgeStage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChatUserMessageMutation) EdgeCleared(name string) bool {
	switch name {
	case chatusermessage.EdgeChat:
		return m.clearedchat
	case chatusermessage.EdgeStage:
		return m.clearedstage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChatUserMessageMutation) ClearEdge(name string) error {
	switch name {
	case chatusermessage.EdgeChat:
		m.ClearChat()
		return nil
	case chatusermessage.EdgeStage:
		m.ClearStage()
		return nil
	}
	return fmt.Errorf("unknown ChatUserMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChatUserMessageMutation) ResetEdge(name string) error {
	switch name {
	case chatusermessage.EdgeChat:
		m.ResetChat()
		return nil
	case chatusermessage.EdgeStage:
		m.ResetStage()
		return nil
	}
	return fmt.Errorf("unknown ChatUserMessage edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op             Op
	typ            string
	id             *int
	channel        *string
	payload        *map[string]interface{}
	created_at     *time.Time
	clearedFields  map[string]struct{}
	session        *string
	clearedsession bool
	done           bool
	oldValue       func(context.Context) (*Event, error)
	predicates     []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *EventMutation) SetSessionID(s string) {
	m.session = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *EventMutation) SessionID() (r string, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *EventMutation) ResetSessionID() {
	m.session = nil
}

// SetChannel sets the "channel" field.
func (m *EventMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *EventMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *EventMutation) ResetChannel() {
	m.channel = nil
}

// SetPayload sets the "payload" field.
func (m *EventMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *EventMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *EventMutation) ResetPayload() {
	m.payload = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearSession clears the "session" edge to the AlertSession entity.
func (m *EventMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[event.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the AlertSession entity was cleared.
func (m *EventMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *EventMutation) SessionIDs() (ids []string) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *EventMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.session != nil {
		fields = append(fields, event.FieldSessionID)
	}
	if m.channel != nil {
		fields = append(fields, event.FieldChannel)
	}
	if m.payload != nil {
		fields = append(fields, event.FieldPayload)
	}
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldSessionID:
		return m.SessionID()
	case event.FieldChannel:
		return m.Channel()
	case event.FieldPayload:
		return m.Payload()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldSessionID:
		return m.OldSessionID(ctx)
	case event.FieldChannel:
		return m.OldChannel(ctx)
	case event.FieldPayload:
		return m.OldPayload(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case event.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case event.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldSessionID:
		m.ResetSessionID()
		return nil
	case event.FieldChannel:
		m.ResetChannel()
		return nil
	case event.FieldPayload:
		m.ResetPayload()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, event.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, event.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// LLMInteractionMutation represents an operation that mutates the LLMInteraction nodes in the graph.
type LLMInteractionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	interaction_type       *llminteraction.InteractionType
	model_name             *string
	llm_request            *map[string]interface{}
	llm_response           *map[string]interface{}
	thinking_content       *string
	response_metadata      *map[string]interface{}
	input_tokens           *int
	addinput_tokens        *int
	output_tokens          *int
	addoutput_tokens       *int
	total_tokens           *int
	addtotal_tokens        *int
	duration_ms            *int
	addduration_ms         *int
	error_message          *string
	clearedFields          map[string]struct{}
	session                *string
	clearedsession         bool
	stage                  *string
	clearedstage           bool
	agent_execution        *string
	clearedagent_execution bool
	last_message           *string
	clearedlast_message    bool
	timeline_events        map[string]struct{}
	removedtimeline_events map[string]struct{}
	clearedtimeline_events bool
	done                   bool
	oldValue               func(context.Context) (*LLMInteraction, error)
	predicates             []predicate.LLMInteraction
}

var _ ent.Mutation = (*LLMInteractionMutation)(nil)

// llminteractionOption allows management of the mutation configuration using functional options.
type llminteractionOption func(*LLMInteractionMutation)

// newLLMInteractionMutation creates new mutation for the LLMInteraction entity.
func newLLMInteractionMutation(c config, op Op, opts ...llminteractionOption) *LLMInteractionMutation {
	m := &LLMInteractionMutation{
		config:        c,
		op:            op,
		typ:           TypeLLMInteraction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLLMInteractionID sets the ID field of the mutation.
func withLLMInteractionID(id string) llminteractionOption {
	return func(m *LLMInteractionMutation) {
		var (
			err   error
			once  sync.Once
			value *LLMInteraction
		)
		m.oldValue = func(ctx context.Context) (*LLMInteraction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LLMInteraction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLLMInteraction sets the old LLMInteraction of the mutation.
func withLLMInteraction(node *LLMInteraction) llminteractionOption {
	return func(m *LLMInteractionMutation) {
		m.oldValue = func(context.Context) (*LLMInteraction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LLMInteractionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LLMInteractionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LLMInteraction entities.
func (m *LLMInteractionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LLMInteractionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LLMInteractionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LLMInteraction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *LLMInteractionMutation) SetSessionID(s string) {
	m.session = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *LLMInteractionMutation) SessionID() (r string, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *LLMInteractionMutation) ResetSessionID() {
	m.session = nil
}

// SetStageID sets the "stage_id" field.
func (m *LLMInteractionMutation) SetStageID(s string) {
	m.stage = &s
}

// StageID returns the value of the "stage_id" field in the mutation.
func (m *LLMInteractionMutation) StageID() (r string, exists bool) {
	v := m.stage
	if v == nil {
		return
	}
	return *v, true
}

// OldStageID returns the old "stage_id" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldStageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStageID: %w", err)
	}
	return oldValue.StageID, nil
}

// ResetStageID resets all changes to the "stage_id" field.
func (m *LLMInteractionMutation) ResetStageID() {
	m.stage = nil
}

// SetExecutionID sets the "execution_id" field.
func (m *LLMInteractionMutation) SetExecutionID(s string) {
	m.agent_execution = &s
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *LLMInteractionMutation) ExecutionID() (r string, exists bool) {
	v := m.agent_execution
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldExecutionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *LLMInteractionMutation) ResetExecutionID() {
	m.agent_execution = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LLMInteractionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LLMInteractionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LLMInteractionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetInteractionType sets the "interaction_type" field.
func (m *LLMInteractionMutation) SetInteractionType(lt llminteraction.InteractionType) {
	m.interaction_type = &lt
}

// InteractionType returns the value of the "interaction_type" field in the mutation.
func (m *LLMInteractionMutation) InteractionType() (r llminteraction.InteractionType, exists bool) {
	v := m.interaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInteractionType returns the old "interaction_type" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldInteractionType(ctx context.Context) (v llminteraction.InteractionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInteractionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInteractionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInteractionType: %w", err)
	}
	return oldValue.InteractionType, nil
}

// ResetInteractionType resets all changes to the "interaction_type" field.
func (m *LLMInteractionMutation) ResetInteractionType() {
	m.interaction_type = nil
}

// SetModelName sets the "model_name" field.
func (m *LLMInteractionMutation) SetModelName(s string) {
	m.model_name = &s
}

// ModelName returns the value of the "model_name" field in the mutation.
func (m *LLMInteractionMutation) ModelName() (r string, exists bool) {
	v := m.model_name
	if v == nil {
		return
	}
	return *v, true
}

// OldModelName returns the old "model_name" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldModelName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelName: %w", err)
	}
	return oldValue.ModelName, nil
}

// ResetModelName resets all changes to the "model_name" field.
func (m *LLMInteractionMutation) ResetModelName() {
	m.model_name = nil
}

// SetLastMessageID sets the "last_message_id" field.
func (m *LLMInteractionMutation) SetLastMessageID(s string) {
	m.last_message = &s
}

// LastMessageID returns the value of the "last_message_id" field in the mutation.
func (m *LLMInteractionMutation) LastMessageID() (r string, exists bool) {
	v := m.last_message
	if v == nil {
		return
	}
	return *v, true
}

// OldLastMessageID returns the old "last_message_id" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldLastMessageID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastMessageID: %w", err)
	}
	return oldValue.LastMessageID, nil
}

// ClearLastMessageID clears the value of the "last_message_id" field.
func (m *LLMInteractionMutation) ClearLastMessageID() {
	m.last_message = nil
	m.clearedFields[llminteraction.FieldLastMessageID] = struct{}{}
}

// LastMessageIDCleared returns if the "last_message_id" field was cleared in this mutation.
func (m *LLMInteractionMutation) LastMessageIDCleared() bool {
	_, ok := m.clearedFields[llminteraction.FieldLastMessageID]
	return ok
}

// ResetLastMessageID resets all changes to the "last_message_id" field.
func (m *LLMInteractionMutation) ResetLastMessageID() {
	m.last_message = nil
	delete(m.clearedFields, llminteraction.FieldLastMessageID)
}

// SetLlmRequest sets the "llm_request" field.
func (m *LLMInteractionMutation) SetLlmRequest(value map[string]interface{}) {
	m.llm_request = &value
}

// LlmRequest returns the value of the "llm_request" field in the mutation.
func (m *LLMInteractionMutation) LlmRequest() (r map[string]interface{}, exists bool) {
	v := m.llm_request
	if v == nil {
		return
	}
	return *v, true
}

// OldLlmRequest returns the old "llm_request" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldLlmRequest(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLlmRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLlmRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLlmRequest: %w", err)
	}
	return oldValue.LlmRequest, nil
}

// ResetLlmRequest resets all changes to the "llm_request" field.
func (m *LLMInteractionMutation) ResetLlmRequest() {
	m.llm_request = nil
}

// SetLlmResponse sets the "llm_response" field.
func (m *LLMInteractionMutation) SetLlmResponse(value map[string]interface{}) {
	m.llm_response = &value
}

// LlmResponse returns the value of the "llm_response" field in the mutation.
func (m *LLMInteractionMutation) LlmResponse() (r map[string]interface{}, exists bool) {
	v := m.llm_response
	if v == nil {
		return
	}
	return *v, true
}

// OldLlmResponse returns the old "llm_response" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldLlmResponse(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLlmResponse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLlmResponse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLlmResponse: %w", err)
	}
	return oldValue.LlmResponse, nil
}

// ResetLlmResponse resets all changes to the "llm_response" field.
func (m *LLMInteractionMutation) ResetLlmResponse() {
	m.llm_response = nil
}

// SetThinkingContent sets the "thinking_content" field.
func (m *LLMInteractionMutation) SetThinkingContent(s string) {
	m.thinking_content = &s
}

// ThinkingContent returns the value of the "thinking_content" field in the mutation.
func (m *LLMInteractionMutation) ThinkingContent() (r string, exists bool) {
	v := m.thinking_content
	if v == nil {
		return
	}
	return *v, true
}

// OldThinkingContent returns the old "thinking_content" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldThinkingContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThinkingContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThinkingContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThinkingContent: %w", err)
	}
	return oldValue.ThinkingContent, nil
}

// ClearThinkingContent clears the value of the "thinking_content" field.
func (m *LLMInteractionMutation) ClearThinkingContent() {
	m.thinking_content = nil
	m.clearedFields[llminteraction.FieldThinkingContent] = struct{}{}
}

// ThinkingContentCleared returns if the "thinking_content" field was cleared in this mutation.
func (m *LLMInteractionMutation) ThinkingContentCleared() bool {
	_, ok := m.clearedFields[llminteraction.FieldThinkingContent]
	return ok
}

// ResetThinkingContent resets all changes to the "thinking_content" field.
func (m *LLMInteractionMutation) ResetThinkingContent() {
	m.thinking_content = nil
	delete(m.clearedFields, llminteraction.FieldThinkingContent)
}

// SetResponseMetadata sets the "response_metadata" field.
func (m *LLMInteractionMutation) SetResponseMetadata(value map[string]interface{}) {
	m.response_metadata = &value
}

// ResponseMetadata returns the value of the "response_metadata" field in the mutation.
func (m *LLMInteractionMutation) ResponseMetadata() (r map[string]interface{}, exists bool) {
	v := m.response_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseMetadata returns the old "response_metadata" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldResponseMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseMetadata: %w", err)
	}
	return oldValue.ResponseMetadata, nil
}

// ClearResponseMetadata clears the value of the "response_metadata" field.
func (m *LLMInteractionMutation) ClearResponseMetadata() {
	m.response_metadata = nil
	m.clearedFields[llminteraction.FieldResponseMetadata] = struct{}{}
}

// ResponseMetadataCleared returns if the "response_metadata" field was cleared in this mutation.
func (m *LLMInteractionMutation) ResponseMetadataCleared() bool {
	_, ok := m.clearedFields[llminteraction.FieldResponseMetadata]
	return ok
}

// ResetResponseMetadata resets all changes to the "response_metadata" field.
func (m *LLMInteractionMutation) ResetResponseMetadata() {
	m.response_metadata = nil
	delete(m.clearedFields, llminteraction.FieldResponseMetadata)
}

// SetInputTokens sets the "input_tokens" field.
func (m *LLMInteractionMutation) SetInputTokens(i int) {
	m.input_tokens = &i
	m.addinput_tokens = nil
}

// InputTokens returns the value of the "input_tokens" field in the mutation.
func (m *LLMInteractionMutation) InputTokens() (r int, exists bool) {
	v := m.input_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldInputTokens returns the old "input_tokens" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldInputTokens(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputTokens: %w", err)
	}
	return oldValue.InputTokens, nil
}

// AddInputTokens adds i to the "input_tokens" field.
func (m *LLMInteractionMutation) AddInputTokens(i int) {
	if m.addinput_tokens != nil {
		*m.addinput_tokens += i
	} else {
		m.addinput_tokens = &i
	}
}

// AddedInputTokens returns the value that was added to the "input_tokens" field in this mutation.
func (m *LLMInteractionMutation) AddedInputTokens() (r int, exists bool) {
	v := m.addinput_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearInputTokens clears the value of the "input_tokens" field.
func (m *LLMInteractionMutation) ClearInputTokens() {
	m.input_tokens = nil
	m.addinput_tokens = nil
	m.clearedFields[llminteraction.FieldInputTokens] = struct{}{}
}

// InputTokensCleared returns if the "input_tokens" field was cleared in this mutation.
func (m *LLMInteractionMutation) InputTokensCleared() bool {
	_, ok := m.clearedFields[llminteraction.FieldInputTokens]
	return ok
}

// ResetInputTokens resets all changes to the "input_tokens" field.
func (m *LLMInteractionMutation) ResetInputTokens() {
	m.input_tokens = nil
	m.addinput_tokens = nil
	delete(m.clearedFields, llminteraction.FieldInputTokens)
}

// SetOutputTokens sets the "output_tokens" field.
func (m *LLMInteractionMutation) SetOutputTokens(i int) {
	m.output_tokens = &i
	m.addoutput_tokens = nil
}

// OutputTokens returns the value of the "output_tokens" field in the mutation.
func (m *LLMInteractionMutation) OutputTokens() (r int, exists bool) {
	v := m.output_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputTokens returns the old "output_tokens" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldOutputTokens(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputTokens: %w", err)
	}
	return oldValue.OutputTokens, nil
}

// AddOutputTokens adds i to the "output_tokens" field.
func (m *LLMInteractionMutation) AddOutputTokens(i int) {
	if m.addoutput_tokens != nil {
		*m.addoutput_tokens += i
	} else {
		m.addoutput_tokens = &i
	}
}

// AddedOutputTokens returns the value that was added to the "output_tokens" field in this mutation.
func (m *LLMInteractionMutation) AddedOutputTokens() (r int, exists bool) {
	v := m.addoutput_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearOutputTokens clears the value of the "output_tokens" field.
func (m *LLMInteractionMutation) ClearOutputTokens() {
	m.output_tokens = nil
	m.addoutput_tokens = nil
	m.clearedFields[llminteraction.FieldOutputTokens] = struct{}{}
}

// OutputTokensCleared returns if the "output_tokens" field was cleared in this mutation.
func (m *LLMInteractionMutation) OutputTokensCleared() bool {
	_, ok := m.clearedFields[llminteraction.FieldOutputTokens]
	return ok
}

// ResetOutputTokens resets all changes to the "output_tokens" field.
func (m *LLMInteractionMutation) ResetOutputTokens() {
	m.output_tokens = nil
	m.addoutput_tokens = nil
	delete(m.clearedFields, llminteraction.FieldOutputTokens)
}

// SetTotalTokens sets the "total_tokens" field.
func (m *LLMInteractionMutation) SetTotalTokens(i int) {
	m.total_tokens = &i
	m.addtotal_tokens = nil
}

// TotalTokens returns the value of the "total_tokens" field in the mutation.
func (m *LLMInteractionMutation) TotalTokens() (r int, exists bool) {
	v := m.total_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTokens returns the old "total_tokens" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldTotalTokens(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTokens: %w", err)
	}
	return oldValue.TotalTokens, nil
}

// AddTotalTokens adds i to the "total_tokens" field.
func (m *LLMInteractionMutation) AddTotalTokens(i int) {
	if m.addtotal_tokens != nil {
		*m.addtotal_tokens += i
	} else {
		m.addtotal_tokens = &i
	}
}

// AddedTotalTokens returns the value that was added to the "total_tokens" field in this mutation.
func (m *LLMInteractionMutation) AddedTotalTokens() (r int, exists bool) {
	v := m.addtotal_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalTokens clears the value of the "total_tokens" field.
func (m *LLMInteractionMutation) ClearTotalTokens() {
	m.total_tokens = nil
	m.addtotal_tokens = nil
	m.clearedFields[llminteraction.FieldTotalTokens] = struct{}{}
}

// TotalTokensCleared returns if the "total_tokens" field was cleared in this mutation.
func (m *LLMInteractionMutation) TotalTokensCleared() bool {
	_, ok := m.clearedFields[llminteraction.FieldTotalTokens]
	return ok
}

// ResetTotalTokens resets all changes to the "total_tokens" field.
func (m *LLMInteractionMutation) ResetTotalTokens() {
	m.total_tokens = nil
	m.addtotal_tokens = nil
	delete(m.clearedFields, llminteraction.FieldTotalTokens)
}

// SetDurationMs sets the "duration_ms" field.
func (m *LLMInteractionMutation) SetDurationMs(i int) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *LLMInteractionMutation) DurationMs() (r int, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldDurationMs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *LLMInteractionMutation) AddDurationMs(i int) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *LLMInteractionMutation) AddedDurationMs() (r int, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *LLMInteractionMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[llminteraction.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *LLMInteractionMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[llminteraction.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *LLMInteractionMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, llminteraction.FieldDurationMs)
}

// SetErrorMessage sets the "error_message" field.
func (m *LLMInteractionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *LLMInteractionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the LLMInteraction entity.
// If the LLMInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LLMInteractionMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *LLMInteractionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[llminteraction.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *LLMInteractionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[llminteraction.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *LLMInteractionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, llminteraction.FieldErrorMessage)
}

// ClearSession clears the "session" edge to the AlertSession entity.
func (m *LLMInteractionMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[llminteraction.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the AlertSession entity was cleared.
func (m *LLMInteractionMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *LLMInteractionMutation) SessionIDs() (ids []string) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *LLMInteractionMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// ClearStage clears the "stage" edge to the Stage entity.
func (m *LLMInteractionMutation) ClearStage() {
	m.clearedstage = true
	m.clearedFields[llminteraction.FieldStageID] = struct{}{}
}

// StageCleared reports if the "stage" edge to the Stage entity was cleared.
func (m *LLMInteractionMutation) StageCleared() bool {
	return m.clearedstage
}

// StageIDs returns the "stage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageID instead. It exists only for internal usage by the builders.
func (m *LLMInteractionMutation) StageIDs() (ids []string) {
	if id := m.stage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStage resets all changes to the "stage" edge.
func (m *LLMInteractionMutation) ResetStage() {
	m.stage = nil
	m.clearedstage = false
}

// SetAgentExecutionID sets the "agent_execution" edge to the AgentExecution entity by id.
func (m *LLMInteractionMutation) SetAgentExecutionID(id string) {
	m.agent_execution = &id
}

// ClearAgentExecution clears the "agent_execution" edge to the AgentExecution entity.
func (m *LLMInteractionMutation) ClearAgentExecution() {
	m.clearedagent_execution = true
	m.clearedFields[llminteraction.FieldExecutionID] = struct{}{}
}

// AgentExecutionCleared reports if the "agent_execution" edge to the AgentExecution entity was cleared.
func (m *LLMInteractionMutation) AgentExecutionCleared() bool {
	return m.clearedagent_execution
}

// AgentExecutionID returns the "agent_execution" edge ID in the mutation.
func (m *LLMInteractionMutation) AgentExecutionID() (id string, exists bool) {
	if m.agent_execution != nil {
		return *m.agent_execution, true
	}
	return
}

// AgentExecutionIDs returns the "agent_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentExecutionID instead. It exists only for internal usage by the builders.
func (m *LLMInteractionMutation) AgentExecutionIDs() (ids []string) {
	if id := m.agent_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgentExecution resets all changes to the "agent_execution" edge.
func (m *LLMInteractionMutation) ResetAgentExecution() {
	m.agent_execution = nil
	m.clearedagent_execution = false
}

// ClearLastMessage clears the "last_message" edge to the Message entity.
func (m *LLMInteractionMutation) ClearLastMessage() {
	m.clearedlast_message = true
	m.clearedFields[llminteraction.FieldLastMessageID] = struct{}{}
}

// LastMessageCleared reports if the "last_message" edge to the Message entity was cleared.
func (m *LLMInteractionMutation) LastMessageCleared() bool {
	return m.LastMessageIDCleared() || m.clearedlast_message
}

// LastMessageIDs returns the "last_message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LastMessageID instead. It exists only for internal usage by the builders.
func (m *LLMInteractionMutation) LastMessageIDs() (ids []string) {
	if id := m.last_message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLastMessage resets all changes to the "last_message" edge.
func (m *LLMInteractionMutation) ResetLastMessage() {
	m.last_message = nil
	m.clearedlast_message = false
}

// AddTimelineEventIDs adds the "timeline_events" edge to the TimelineEvent entity by ids.
func (m *LLMInteractionMutation) AddTimelineEventIDs(ids ...string) {
	if m.timeline_events == nil {
		m.timeline_events = make(map[string]struct{})
	}
	for i := range ids {
		m.timeline_events[ids[i]] = struct{}{}
	}
}

// ClearTimelineEvents clears the "timeline_events" edge to the TimelineEvent entity.
func (m *LLMInteractionMutation) ClearTimelineEvents() {
	m.clearedtimeline_events = true
}

// TimelineEventsCleared reports if the "timeline_events" edge to the TimelineEvent entity was cleared.
func (m *LLMInteractionMutation) TimelineEventsCleared() bool {
	return m.clearedtimeline_events
}

// RemoveTimelineEventIDs removes the "timeline_events" edge to the TimelineEvent entity by IDs.
func (m *LLMInteractionMutation) RemoveTimelineEventIDs(ids ...string) {
	if m.removedtimeline_events == nil {
		m.removedtimeline_events = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.timeline_events, ids[i])
		m.removedtimeline_events[ids[i]] = struct{}{}
	}
}

// RemovedTimelineEvents returns the removed IDs of the "timeline_events" edge to the TimelineEvent entity.
func (m *LLMInteractionMutation) RemovedTimelineEventsIDs() (ids []string) {
	for id := range m.removedtimeline_events {
		ids = append(ids, id)
	}
	return
}

// TimelineEventsIDs returns the "timeline_events" edge IDs in the mutation.
func (m *LLMInteractionMutation) TimelineEventsIDs() (ids []string) {
	for id := range m.timeline_events {
		ids = append(ids, id)
	}
	return
}

// ResetTimelineEvents resets all changes to the "timeline_events" edge.
func (m *LLMInteractionMutation) ResetTimelineEvents() {
	m.timeline_events = nil
	m.clearedtimeline_events = false
	m.removedtimeline_events = nil
}

// Where appends a list predicates to the LLMInteractionMutation builder.
func (m *LLMInteractionMutation) Where(ps ...predicate.LLMInteraction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LLMInteractionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LLMInteractionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LLMInteraction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LLMInteractionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LLMInteractionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LLMInteraction).
func (m *LLMInteractionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LLMInteractionMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.session != nil {
		fields = append(fields, llminteraction.FieldSessionID)
	}
	if m.stage != nil {
		fields = append(fields, llminteraction.FieldStageID)
	}
	if m.agent_execution != nil {
		fields = append(fields, llminteraction.FieldExecutionID)
	}
	if m.created_at != nil {
		fields = append(fields, llminteraction.FieldCreatedAt)
	}
	if m.interaction_type != nil {
		fields = append(fields, llminteraction.FieldInteractionType)
	}
	if m.model_name != nil {
		fields = append(fields, llminteraction.FieldModelName)
	}
	if m.last_message != nil {
		fields = append(fields, llminteraction.FieldLastMessageID)
	}
	if m.llm_request != nil {
		fields = append(fields, llminteraction.FieldLlmRequest)
	}
	if m.llm_response != nil {
		fields = append(fields, llminteraction.FieldLlmResponse)
	}
	if m.thinking_content != nil {
		fields = append(fields, llminteraction.FieldThinkingContent)
	}
	if m.response_metadata != nil {
		fields = append(fields, llminteraction.FieldResponseMetadata)
	}
	if m.input_tokens != nil {
		fields = append(fields, llminteraction.FieldInputTokens)
	}
	if m.output_tokens != nil {
		fields = append(fields, llminteraction.FieldOutputTokens)
	}
	if m.total_tokens != nil {
		fields = append(fields, llminteraction.FieldTotalTokens)
	}
	if m.duration_ms != nil {
		fields = append(fields, llminteraction.FieldDurationMs)
	}
	if m.error_message != nil {
		fields = append(fields, llminteraction.FieldErrorMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LLMInteractionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case llminteraction.FieldSessionID:
		return m.SessionID()
	case llminteraction.FieldStageID:
		return m.StageID()
	case llminteraction.FieldExecutionID:
		return m.ExecutionID()
	case llminteraction.FieldCreatedAt:
		return m.CreatedAt()
	case llminteraction.FieldInteractionType:
		return m.InteractionType()
	case llminteraction.FieldModelName:
		return m.ModelName()
	case llminteraction.FieldLastMessageID:
		return m.LastMessageID()
	case llminteraction.FieldLlmRequest:
		return m.LlmRequest()
	case llminteraction.FieldLlmResponse:
		return m.LlmResponse()
	case llminteraction.FieldThinkingContent:
		return m.ThinkingContent()
	case llminteraction.FieldResponseMetadata:
		return m.ResponseMetadata()
	case llminteraction.FieldInputTokens:
		return m.InputTokens()
	case llminteraction.FieldOutputTokens:
		return m.OutputTokens()
	case llminteraction.FieldTotalTokens:
		return m.TotalTokens()
	case llminteraction.FieldDurationMs:
		return m.DurationMs()
	case llminteraction.FieldErrorMessage:
		return m.ErrorMessage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LLMInteractionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case llminteraction.FieldSessionID:
		return m.OldSessionID(ctx)
	case llminteraction.FieldStageID:
		return m.OldStageID(ctx)
	case llminteraction.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case llminteraction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case llminteraction.FieldInteractionType:
		return m.OldInteractionType(ctx)
	case llminteraction.FieldModelName:
		return m.OldModelName(ctx)
	case llminteraction.FieldLastMessageID:
		return m.OldLastMessageID(ctx)
	case llminteraction.FieldLlmRequest:
		return m.OldLlmRequest(ctx)
	case llminteraction.FieldLlmResponse:
		return m.OldLlmResponse(ctx)
	case llminteraction.FieldThinkingContent:
		return m.OldThinkingContent(ctx)
	case llminteraction.FieldResponseMetadata:
		return m.OldResponseMetadata(ctx)
	case llminteraction.FieldInputTokens:
		return m.OldInputTokens(ctx)
	case llminteraction.FieldOutputTokens:
		return m.OldOutputTokens(ctx)
	case llminteraction.FieldTotalTokens:
		return m.OldTotalTokens(ctx)
	case llminteraction.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case llminteraction.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	}
	return nil, fmt.Errorf("unknown LLMInteraction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LLMInteractionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case llminteraction.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case llminteraction.FieldStageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStageID(v)
		return nil
	case llminteraction.FieldExecutionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case llminteraction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case llminteraction.FieldInteractionType:
		v, ok := value.(llminteraction.InteractionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInteractionType(v)
		return nil
	case llminteraction.FieldModelName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelName(v)
		return nil
	case llminteraction.FieldLastMessageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastMessageID(v)
		return nil
	case llminteraction.FieldLlmRequest:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLlmRequest(v)
		return nil
	case llminteraction.FieldLlmResponse:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLlmResponse(v)
		return nil
	case llminteraction.FieldThinkingContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThinkingContent(v)
		return nil
	case llminteraction.FieldResponseMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseMetadata(v)
		return nil
	case llminteraction.FieldInputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputTokens(v)
		return nil
	case llminteraction.FieldOutputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputTokens(v)
		return nil
	case llminteraction.FieldTotalTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTokens(v)
		return nil
	case llminteraction.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case llminteraction.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	}
	return fmt.Errorf("unknown LLMInteraction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LLMInteractionMutation) AddedFields() []string {
	var fields []string
	if m.addinput_tokens != nil {
		fields = append(fields, llminteraction.FieldInputTokens)
	}
	if m.addoutput_tokens != nil {
		fields = append(fields, llminteraction.FieldOutputTokens)
	}
	if m.addtotal_tokens != nil {
		fields = append(fields, llminteraction.FieldTotalTokens)
	}
	if m.addduration_ms != nil {
		fields = append(fields, llminteraction.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LLMInteractionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case llminteraction.FieldInputTokens:
		return m.AddedInputTokens()
	case llminteraction.FieldOutputTokens:
		return m.AddedOutputTokens()
	case llminteraction.FieldTotalTokens:
		return m.AddedTotalTokens()
	case llminteraction.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LLMInteractionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case llminteraction.FieldInputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInputTokens(v)
		return nil
	case llminteraction.FieldOutputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputTokens(v)
		return nil
	case llminteraction.FieldTotalTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTokens(v)
		return nil
	case llminteraction.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown LLMInteraction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LLMInteractionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(llminteraction.FieldLastMessageID) {
		fields = append(fields, llminteraction.FieldLastMessageID)
	}
	if m.FieldCleared(llminteraction.FieldThinkingContent) {
		fields = append(fields, llminteraction.FieldThinkingContent)
	}
	if m.FieldCleared(llminteraction.FieldResponseMetadata) {
		fields = append(fields, llminteraction.FieldResponseMetadata)
	}
	if m.FieldCleared(llminteraction.FieldInputTokens) {
		fields = append(fields, llminteraction.FieldInputTokens)
	}
	if m.FieldCleared(llminteraction.FieldOutputTokens) {
		fields = append(fields, llminteraction.FieldOutputTokens)
	}
	if m.FieldCleared(llminteraction.FieldTotalTokens) {
		fields = append(fields, llminteraction.FieldTotalTokens)
	}
	if m.FieldCleared(llminteraction.FieldDurationMs) {
		fields = append(fields, llminteraction.FieldDurationMs)
	}
	if m.FieldCleared(llminteraction.FieldErrorMessage) {
		fields = append(fields, llminteraction.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LLMInteractionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LLMInteractionMutation) ClearField(name string) error {
	switch name {
	case llminteraction.FieldLastMessageID:
		m.ClearLastMessageID()
		return nil
	case llminteraction.FieldThinkingContent:
		m.ClearThinkingContent()
		return nil
	case llminteraction.FieldResponseMetadata:
		m.ClearResponseMetadata()
		return nil
	case llminteraction.FieldInputTokens:
		m.ClearInputTokens()
		return nil
	case llminteraction.FieldOutputTokens:
		m.ClearOutputTokens()
		return nil
	case llminteraction.FieldTotalTokens:
		m.ClearTotalTokens()
		return nil
	case llminteraction.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	case llminteraction.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown LLMInteraction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LLMInteractionMutation) ResetField(name string) error {
	switch name {
	case llminteraction.FieldSessionID:
		m.ResetSessionID()
		return nil
	case llminteraction.FieldStageID:
		m.ResetStageID()
		return nil
	case llminteraction.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case llminteraction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case llminteraction.FieldInteractionType:
		m.ResetInteractionType()
		return nil
	case llminteraction.FieldModelName:
		m.ResetModelName()
		return nil
	case llminteraction.FieldLastMessageID:
		m.ResetLastMessageID()
		return nil
	case llminteraction.FieldLlmRequest:
		m.ResetLlmRequest()
		return nil
	case llminteraction.FieldLlmResponse:
		m.ResetLlmResponse()
		return nil
	case llminteraction.FieldThinkingContent:
		m.ResetThinkingContent()
		return nil
	case llminteraction.FieldResponseMetadata:
		m.ResetResponseMetadata()
		return nil
	case llminteraction.FieldInputTokens:
		m.ResetInputTokens()
		return nil
	case llminteraction.FieldOutputTokens:
		m.ResetOutputTokens()
		return nil
	case llminteraction.FieldTotalTokens:
		m.ResetTotalTokens()
		return nil
	case llminteraction.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case llminteraction.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown LLMInteraction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LLMInteractionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.session != nil {
		edges = append(edges, llminteraction.EdgeSession)
	}
	if m.stage != nil {
		edges = append(edges, llminteraction.EdgeStage)
	}
	if m.agent_execution != nil {
		edges = append(edges, llminteraction.EdgeAgentExecution)
	}
	if m.last_message != nil {
		edges = append(edges, llminteraction.EdgeLastMessage)
	}
	if m.timeline_events != nil {
		edges = append(edges, llminteraction.EdgeTimelineEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LLMInteractionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case llminteraction.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case llminteraction.EdgeStage:
		if id := m.stage; id != nil {
			return []ent.Value{*id}
		}
	case llminteraction.EdgeAgentExecution:
		if id := m.agent_execution; id != nil {
			return []ent.Value{*id}
		}
	case llminteraction.EdgeLastMessage:
		if id := m.last_message; id != nil {
			return []ent.Value{*id}
		}
	case llminteraction.EdgeTimelineEvents:
		ids := make([]ent.Value, 0, len(m.timeline_events))
		for id := range m.timeline_events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LLMInteractionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtimeline_events != nil {
		edges = append(edges, llminteraction.EdgeTimelineEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LLMInteractionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case llminteraction.EdgeTimelineEvents:
		ids := make([]ent.Value, 0, len(m.removedtimeline_events))
		for id := range m.removedtimeline_events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LLMInteractionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedsession {
		edges = append(edges, llminteraction.EdgeSession)
	}
	if m.clearedstage {
		edges = append(edges, llminteraction.EdgeStage)
	}
	if m.clearedagent_execution {
		edges = append(edges, llminteraction.EdgeAgentExecution)
	}
	if m.clearedlast_message {
		edges = append(edges, llminteraction.EdgeLastMessage)
	}
	if m.clearedtimeline_events {
		edges = append(edges, llminteraction.EdgeTimelineEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LLMInteractionMutation) EdgeCleared(name string) bool {
	switch name {
	case llminteraction.EdgeSession:
		return m.clearedsession
	case llminteraction.EdgeStage:
		return m.clearedstage
	case llminteraction.EdgeAgentExecution:
		return m.clearedagent_execution
	case llminteraction.EdgeLastMessage:
		return m.clearedlast_message
	case llminteraction.EdgeTimelineEvents:
		return m.clearedtimeline_events
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LLMInteractionMutation) ClearEdge(name string) error {
	switch name {
	case llminteraction.EdgeSession:
		m.ClearSession()
		return nil
	case llminteraction.EdgeStage:
		m.ClearStage()
		return nil
	case llminteraction.EdgeAgentExecution:
		m.ClearAgentExecution()
		return nil
	case llminteraction.EdgeLastMessage:
		m.ClearLastMessage()
		return nil
	}
	return fmt.Errorf("unknown LLMInteraction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LLMInteractionMutation) ResetEdge(name string) error {
	switch name {
	case llminteraction.EdgeSession:
		m.ResetSession()
		return nil
	case llminteraction.EdgeStage:
		m.ResetStage()
		return nil
	case llminteraction.EdgeAgentExecution:
		m.ResetAgentExecution()
		return nil
	case llminteraction.EdgeLastMessage:
		m.ResetLastMessage()
		return nil
	case llminteraction.EdgeTimelineEvents:
		m.ResetTimelineEvents()
		return nil
	}
	return fmt.Errorf("unknown LLMInteraction edge %s", name)
}

// MCPInteractionMutation represents an operation that mutates the MCPInteraction nodes in the graph.
type MCPInteractionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	interaction_type       *mcpinteraction.InteractionType
	server_name            *string
	tool_name              *string
	tool_arguments         *map[string]interface{}
	tool_result            *map[string]interface{}
	available_tools        *[]interface{}
	appendavailable_tools  []interface{}
	duration_ms            *int
	addduration_ms         *int
	error_message          *string
	clearedFields          map[string]struct{}
	session                *string
	clearedsession         bool
	stage                  *string
	clearedstage           bool
	agent_execution        *string
	clearedagent_execution bool
	timeline_events        map[string]struct{}
	removedtimeline_events map[string]struct{}
	clearedtimeline_events bool
	done                   bool
	oldValue               func(context.Context) (*MCPInteraction, error)
	predicates             []predicate.MCPInteraction
}

var _ ent.Mutation = (*MCPInteractionMutation)(nil)

// mcpinteractionOption allows management of the mutation configuration using functional options.
type mcpinteractionOption func(*MCPInteractionMutation)

// newMCPInteractionMutation creates new mutation for the MCPInteraction entity.
func newMCPInteractionMutation(c config, op Op, opts ...mcpinteractionOption) *MCPInteractionMutation {
	m := &MCPInteractionMutation{
		config:        c,
		op:            op,
		typ:           TypeMCPInteraction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMCPInteractionID sets the ID field of the mutation.
func withMCPInteractionID(id string) mcpinteractionOption {
	return func(m *MCPInteractionMutation) {
		var (
			err   error
			once  sync.Once
			value *MCPInteraction
		)
		m.oldValue = func(ctx context.Context) (*MCPInteraction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MCPInteraction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMCPInteraction sets the old MCPInteraction of the mutation.
func withMCPInteraction(node *MCPInteraction) mcpinteractionOption {
	return func(m *MCPInteractionMutation) {
		m.oldValue = func(context.Context) (*MCPInteraction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MCPInteractionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MCPInteractionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MCPInteraction entities.
func (m *MCPInteractionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MCPInteractionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MCPInteractionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MCPInteraction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *MCPInteractionMutation) SetSessionID(s string) {
	m.session = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *MCPInteractionMutation) SessionID() (r string, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *MCPInteractionMutation) ResetSessionID() {
	m.session = nil
}

// SetStageID sets the "stage_id" field.
func (m *MCPInteractionMutation) SetStageID(s string) {
	m.stage = &s
}

// StageID returns the value of the "stage_id" field in the mutation.
func (m *MCPInteractionMutation) StageID() (r string, exists bool) {
	v := m.stage
	if v == nil {
		return
	}
	return *v, true
}

// OldStageID returns the old "stage_id" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldStageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStageID: %w", err)
	}
	return oldValue.StageID, nil
}

// ResetStageID resets all changes to the "stage_id" field.
func (m *MCPInteractionMutation) ResetStageID() {
	m.stage = nil
}

// SetExecutionID sets the "execution_id" field.
func (m *MCPInteractionMutation) SetExecutionID(s string) {
	m.agent_execution = &s
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *MCPInteractionMutation) ExecutionID() (r string, exists bool) {
	v := m.agent_execution
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldExecutionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *MCPInteractionMutation) ResetExecutionID() {
	m.agent_execution = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MCPInteractionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MCPInteractionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MCPInteractionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetInteractionType sets the "interaction_type" field.
func (m *MCPInteractionMutation) SetInteractionType(mt mcpinteraction.InteractionType) {
	m.interaction_type = &mt
}

// InteractionType returns the value of the "interaction_type" field in the mutation.
func (m *MCPInteractionMutation) InteractionType() (r mcpinteraction.InteractionType, exists bool) {
	v := m.interaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInteractionType returns the old "interaction_type" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldInteractionType(ctx context.Context) (v mcpinteraction.InteractionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInteractionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInteractionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInteractionType: %w", err)
	}
	return oldValue.InteractionType, nil
}

// ResetInteractionType resets all changes to the "interaction_type" field.
func (m *MCPInteractionMutation) ResetInteractionType() {
	m.interaction_type = nil
}

// SetServerName sets the "server_name" field.
func (m *MCPInteractionMutation) SetServerName(s string) {
	m.server_name = &s
}

// ServerName returns the value of the "server_name" field in the mutation.
func (m *MCPInteractionMutation) ServerName() (r string, exists bool) {
	v := m.server_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServerName returns the old "server_name" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldServerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerName: %w", err)
	}
	return oldValue.ServerName, nil
}

// ResetServerName resets all changes to the "server_name" field.
func (m *MCPInteractionMutation) ResetServerName() {
	m.server_name = nil
}

// SetToolName sets the "tool_name" field.
func (m *MCPInteractionMutation) SetToolName(s string) {
	m.tool_name = &s
}

// ToolName returns the value of the "tool_name" field in the mutation.
func (m *MCPInteractionMutation) ToolName() (r string, exists bool) {
	v := m.tool_name
	if v == nil {
		return
	}
	return *v, true
}

// OldToolName returns the old "tool_name" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldToolName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolName: %w", err)
	}
	return oldValue.ToolName, nil
}

// ClearToolName clears the value of the "tool_name" field.
func (m *MCPInteractionMutation) ClearToolName() {
	m.tool_name = nil
	m.clearedFields[mcpinteraction.FieldToolName] = struct{}{}
}

// ToolNameCleared returns if the "tool_name" field was cleared in this mutation.
func (m *MCPInteractionMutation) ToolNameCleared() bool {
	_, ok := m.clearedFields[mcpinteraction.FieldToolName]
	return ok
}

// ResetToolName resets all changes to the "tool_name" field.
func (m *MCPInteractionMutation) ResetToolName() {
	m.tool_name = nil
	delete(m.clearedFields, mcpinteraction.FieldToolName)
}

// SetToolArguments sets the "tool_arguments" field.
func (m *MCPInteractionMutation) SetToolArguments(value map[string]interface{}) {
	m.tool_arguments = &value
}

// ToolArguments returns the value of the "tool_arguments" field in the mutation.
func (m *MCPInteractionMutation) ToolArguments() (r map[string]interface{}, exists bool) {
	v := m.tool_arguments
	if v == nil {
		return
	}
	return *v, true
}

// OldToolArguments returns the old "tool_arguments" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldToolArguments(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolArguments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolArguments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolArguments: %w", err)
	}
	return oldValue.ToolArguments, nil
}

// ClearToolArguments clears the value of the "tool_arguments" field.
func (m *MCPInteractionMutation) ClearToolArguments() {
	m.tool_arguments = nil
	m.clearedFields[mcpinteraction.FieldToolArguments] = struct{}{}
}

// ToolArgumentsCleared returns if the "tool_arguments" field was cleared in this mutation.
func (m *MCPInteractionMutation) ToolArgumentsCleared() bool {
	_, ok := m.clearedFields[mcpinteraction.FieldToolArguments]
	return ok
}

// ResetToolArguments resets all changes to the "tool_arguments" field.
func (m *MCPInteractionMutation) ResetToolArguments() {
	m.tool_arguments = nil
	delete(m.clearedFields, mcpinteraction.FieldToolArguments)
}

// SetToolResult sets the "tool_result" field.
func (m *MCPInteractionMutation) SetToolResult(value map[string]interface{}) {
	m.tool_result = &value
}

// ToolResult returns the value of the "tool_result" field in the mutation.
func (m *MCPInteractionMutation) ToolResult() (r map[string]interface{}, exists bool) {
	v := m.tool_result
	if v == nil {
		return
	}
	return *v, true
}

// OldToolResult returns the old "tool_result" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldToolResult(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolResult: %w", err)
	}
	return oldValue.ToolResult, nil
}

// ClearToolResult clears the value of the "tool_result" field.
func (m *MCPInteractionMutation) ClearToolResult() {
	m.tool_result = nil
	m.clearedFields[mcpinteraction.FieldToolResult] = struct{}{}
}

// ToolResultCleared returns if the "tool_result" field was cleared in this mutation.
func (m *MCPInteractionMutation) ToolResultCleared() bool {
	_, ok := m.clearedFields[mcpinteraction.FieldToolResult]
	return ok
}

// ResetToolResult resets all changes to the "tool_result" field.
func (m *MCPInteractionMutation) ResetToolResult() {
	m.tool_result = nil
	delete(m.clearedFields, mcpinteraction.FieldToolResult)
}

// SetAvailableTools sets the "available_tools" field.
func (m *MCPInteractionMutation) SetAvailableTools(i []interface{}) {
	m.available_tools = &i
	m.appendavailable_tools = nil
}

// AvailableTools returns the value of the "available_tools" field in the mutation.
func (m *MCPInteractionMutation) AvailableTools() (r []interface{}, exists bool) {
	v := m.available_tools
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableTools returns the old "available_tools" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldAvailableTools(ctx context.Context) (v []interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableTools is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableTools requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableTools: %w", err)
	}
	return oldValue.AvailableTools, nil
}

// AppendAvailableTools adds i to the "available_tools" field.
func (m *MCPInteractionMutation) AppendAvailableTools(i []interface{}) {
	m.appendavailable_tools = append(m.appendavailable_tools, i...)
}

// AppendedAvailableTools returns the list of values that were appended to the "available_tools" field in this mutation.
func (m *MCPInteractionMutation) AppendedAvailableTools() ([]interface{}, bool) {
	if len(m.appendavailable_tools) == 0 {
		return nil, false
	}
	return m.appendavailable_tools, true
}

// ClearAvailableTools clears the value of the "available_tools" field.
func (m *MCPInteractionMutation) ClearAvailableTools() {
	m.available_tools = nil
	m.appendavailable_tools = nil
	m.clearedFields[mcpinteraction.FieldAvailableTools] = struct{}{}
}

// AvailableToolsCleared returns if the "available_tools" field was cleared in this mutation.
func (m *MCPInteractionMutation) AvailableToolsCleared() bool {
	_, ok := m.clearedFields[mcpinteraction.FieldAvailableTools]
	return ok
}

// ResetAvailableTools resets all changes to the "available_tools" field.
func (m *MCPInteractionMutation) ResetAvailableTools() {
	m.available_tools = nil
	m.appendavailable_tools = nil
	delete(m.clearedFields, mcpinteraction.FieldAvailableTools)
}

// SetDurationMs sets the "duration_ms" field.
func (m *MCPInteractionMutation) SetDurationMs(i int) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *MCPInteractionMutation) DurationMs() (r int, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldDurationMs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *MCPInteractionMutation) AddDurationMs(i int) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *MCPInteractionMutation) AddedDurationMs() (r int, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *MCPInteractionMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[mcpinteraction.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *MCPInteractionMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[mcpinteraction.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *MCPInteractionMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, mcpinteraction.FieldDurationMs)
}

// SetErrorMessage sets the "error_message" field.
func (m *MCPInteractionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *MCPInteractionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the MCPInteraction entity.
// If the MCPInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MCPInteractionMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *MCPInteractionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[mcpinteraction.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *MCPInteractionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[mcpinteraction.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *MCPInteractionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, mcpinteraction.FieldErrorMessage)
}

// ClearSession clears the "session" edge to the AlertSession entity.
func (m *MCPInteractionMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[mcpinteraction.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the AlertSession entity was cleared.
func (m *MCPInteractionMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *MCPInteractionMutation) SessionIDs() (ids []string) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *MCPInteractionMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// ClearStage clears the "stage" edge to the Stage entity.
func (m *MCPInteractionMutation) ClearStage() {
	m.clearedstage = true
	m.clearedFields[mcpinteraction.FieldStageID] = struct{}{}
}

// StageCleared reports if the "stage" edge to the Stage entity was cleared.
func (m *MCPInteractionMutation) StageCleared() bool {
	return m.clearedstage
}

// StageIDs returns the "stage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageID instead. It exists only for internal usage by the builders.
func (m *MCPInteractionMutation) StageIDs() (ids []string) {
	if id := m.stage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStage resets all changes to the "stage" edge.
func (m *MCPInteractionMutation) ResetStage() {
	m.stage = nil
	m.clearedstage = false
}

// SetAgentExecutionID sets the "agent_execution" edge to the AgentExecution entity by id.
func (m *MCPInteractionMutation) SetAgentExecutionID(id string) {
	m.agent_execution = &id
}

// ClearAgentExecution clears the "agent_execution" edge to the AgentExecution entity.
func (m *MCPInteractionMutation) ClearAgentExecution() {
	m.clearedagent_execution = true
	m.clearedFields[mcpinteraction.FieldExecutionID] = struct{}{}
}

// AgentExecutionCleared reports if the "agent_execution" edge to the AgentExecution entity was cleared.
func (m *MCPInteractionMutation) AgentExecutionCleared() bool {
	return m.clearedagent_execution
}

// AgentExecutionID returns the "agent_execution" edge ID in the mutation.
func (m *MCPInteractionMutation) AgentExecutionID() (id string, exists bool) {
	if m.agent_execution != nil {
		return *m.agent_execution, true
	}
	return
}

// AgentExecutionIDs returns the "agent_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentExecutionID instead. It exists only for internal usage by the builders.
func (m *MCPInteractionMutation) AgentExecutionIDs() (ids []string) {
	if id := m.agent_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgentExecution resets all changes to the "agent_execution" edge.
func (m *MCPInteractionMutation) ResetAgentExecution() {
	m.agent_execution = nil
	m.clearedagent_execution = false
}

// AddTimelineEventIDs adds the "timeline_events" edge to the TimelineEvent entity by ids.
func (m *MCPInteractionMutation) AddTimelineEventIDs(ids ...string) {
	if m.timeline_events == nil {
		m.timeline_events = make(map[string]struct{})
	}
	for i := range ids {
		m.timeline_events[ids[i]] = struct{}{}
	}
}

// ClearTimelineEvents clears the "timeline_events" edge to the TimelineEvent entity.
func (m *MCPInteractionMutation) ClearTimelineEvents() {
	m.clearedtimeline_events = true
}

// TimelineEventsCleared reports if the "timeline_events" edge to the TimelineEvent entity was cleared.
func (m *MCPInteractionMutation) TimelineEventsCleared() bool {
	return m.clearedtimeline_events
}

// RemoveTimelineEventIDs removes the "timeline_events" edge to the TimelineEvent entity by IDs.
func (m *MCPInteractionMutation) RemoveTimelineEventIDs(ids ...string) {
	if m.removedtimeline_events == nil {
		m.removedtimeline_events = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.timeline_events, ids[i])
		m.removedtimeline_events[ids[i]] = struct{}{}
	}
}

// RemovedTimelineEvents returns the removed IDs of the "timeline_events" edge to the TimelineEvent entity.
func (m *MCPInteractionMutation) RemovedTimelineEventsIDs() (ids []string) {
	for id := range m.removedtimeline_events {
		ids = append(ids, id)
	}
	return
}

// TimelineEventsIDs returns the "timeline_events" edge IDs in the mutation.
func (m *MCPInteractionMutation) TimelineEventsIDs() (ids []string) {
	for id := range m.timeline_events {
		ids = append(ids, id)
	}
	return
}

// ResetTimelineEvents resets all changes to the "timeline_events" edge.
func (m *MCPInteractionMutation) ResetTimelineEvents() {
	m.timeline_events = nil
	m.clearedtimeline_events = false
	m.removedtimeline_events = nil
}

// Where appends a list predicates to the MCPInteractionMutation builder.
func (m *MCPInteractionMutation) Where(ps ...predicate.MCPInteraction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MCPInteractionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MCPInteractionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MCPInteraction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MCPInteractionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MCPInteractionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MCPInteraction).
func (m *MCPInteractionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MCPInteractionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.session != nil {
		fields = append(fields, mcpinteraction.FieldSessionID)
	}
	if m.stage != nil {
		fields = append(fields, mcpinteraction.FieldStageID)
	}
	if m.agent_execution != nil {
		fields = append(fields, mcpinteraction.FieldExecutionID)
	}
	if m.created_at != nil {
		fields = append(fields, mcpinteraction.FieldCreatedAt)
	}
	if m.interaction_type != nil {
		fields = append(fields, mcpinteraction.FieldInteractionType)
	}
	if m.server_name != nil {
		fields = append(fields, mcpinteraction.FieldServerName)
	}
	if m.tool_name != nil {
		fields = append(fields, mcpinteraction.FieldToolName)
	}
	if m.tool_arguments != nil {
		fields = append(fields, mcpinteraction.FieldToolArguments)
	}
	if m.tool_result != nil {
		fields = append(fields, mcpinteraction.FieldToolResult)
	}
	if m.available_tools != nil {
		fields = append(fields, mcpinteraction.FieldAvailableTools)
	}
	if m.duration_ms != nil {
		fields = append(fields, mcpinteraction.FieldDurationMs)
	}
	if m.error_message != nil {
		fields = append(fields, mcpinteraction.FieldErrorMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MCPInteractionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mcpinteraction.FieldSessionID:
		return m.SessionID()
	case mcpinteraction.FieldStageID:
		return m.StageID()
	case mcpinteraction.FieldExecutionID:
		return m.ExecutionID()
	case mcpinteraction.FieldCreatedAt:
		return m.CreatedAt()
	case mcpinteraction.FieldInteractionType:
		return m.InteractionType()
	case mcpinteraction.FieldServerName:
		return m.ServerName()
	case mcpinteraction.FieldToolName:
		return m.ToolName()
	case mcpinteraction.FieldToolArguments:
		return m.ToolArguments()
	case mcpinteraction.FieldToolResult:
		return m.ToolResult()
	case mcpinteraction.FieldAvailableTools:
		return m.AvailableTools()
	case mcpinteraction.FieldDurationMs:
		return m.DurationMs()
	case mcpinteraction.FieldErrorMessage:
		return m.ErrorMessage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MCPInteractionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mcpinteraction.FieldSessionID:
		return m.OldSessionID(ctx)
	case mcpinteraction.FieldStageID:
		return m.OldStageID(ctx)
	case mcpinteraction.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case mcpinteraction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mcpinteraction.FieldInteractionType:
		return m.OldInteractionType(ctx)
	case mcpinteraction.FieldServerName:
		return m.OldServerName(ctx)
	case mcpinteraction.FieldToolName:
		return m.OldToolName(ctx)
	case mcpinteraction.FieldToolArguments:
		return m.OldToolArguments(ctx)
	case mcpinteraction.FieldToolResult:
		return m.OldToolResult(ctx)
	case mcpinteraction.FieldAvailableTools:
		return m.OldAvailableTools(ctx)
	case mcpinteraction.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case mcpinteraction.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	}
	return nil, fmt.Errorf("unknown MCPInteraction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MCPInteractionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mcpinteraction.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case mcpinteraction.FieldStageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStageID(v)
		return nil
	case mcpinteraction.FieldExecutionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case mcpinteraction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mcpinteraction.FieldInteractionType:
		v, ok := value.(mcpinteraction.InteractionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInteractionType(v)
		return nil
	case mcpinteraction.FieldServerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerName(v)
		return nil
	case mcpinteraction.FieldToolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolName(v)
		return nil
	case mcpinteraction.FieldToolArguments:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolArguments(v)
		return nil
	case mcpinteraction.FieldToolResult:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolResult(v)
		return nil
	case mcpinteraction.FieldAvailableTools:
		v, ok := value.([]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableTools(v)
		return nil
	case mcpinteraction.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case mcpinteraction.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	}
	return fmt.Errorf("unknown MCPInteraction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MCPInteractionMutation) AddedFields() []string {
	var fields []string
	if m.addduration_ms != nil {
		fields = append(fields, mcpinteraction.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MCPInteractionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mcpinteraction.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MCPInteractionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mcpinteraction.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown MCPInteraction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MCPInteractionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mcpinteraction.FieldToolName) {
		fields = append(fields, mcpinteraction.FieldToolName)
	}
	if m.FieldCleared(mcpinteraction.FieldToolArguments) {
		fields = append(fields, mcpinteraction.FieldToolArguments)
	}
	if m.FieldCleared(mcpinteraction.FieldToolResult) {
		fields = append(fields, mcpinteraction.FieldToolResult)
	}
	if m.FieldCleared(mcpinteraction.FieldAvailableTools) {
		fields = append(fields, mcpinteraction.FieldAvailableTools)
	}
	if m.FieldCleared(mcpinteraction.FieldDurationMs) {
		fields = append(fields, mcpinteraction.FieldDurationMs)
	}
	if m.FieldCleared(mcpinteraction.FieldErrorMessage) {
		fields = append(fields, mcpinteraction.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MCPInteractionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MCPInteractionMutation) ClearField(name string) error {
	switch name {
	case mcpinteraction.FieldToolName:
		m.ClearToolName()
		return nil
	case mcpinteraction.FieldToolArguments:
		m.ClearToolArguments()
		return nil
	case mcpinteraction.FieldToolResult:
		m.ClearToolResult()
		return nil
	case mcpinteraction.FieldAvailableTools:
		m.ClearAvailableTools()
		return nil
	case mcpinteraction.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	case mcpinteraction.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown MCPInteraction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MCPInteractionMutation) ResetField(name string) error {
	switch name {
	case mcpinteraction.FieldSessionID:
		m.ResetSessionID()
		return nil
	case mcpinteraction.FieldStageID:
		m.ResetStageID()
		return nil
	case mcpinteraction.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case mcpinteraction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mcpinteraction.FieldInteractionType:
		m.ResetInteractionType()
		return nil
	case mcpinteraction.FieldServerName:
		m.ResetServerName()
		return nil
	case mcpinteraction.FieldToolName:
		m.ResetToolName()
		return nil
	case mcpinteraction.FieldToolArguments:
		m.ResetToolArguments()
		return nil
	case mcpinteraction.FieldToolResult:
		m.ResetToolResult()
		return nil
	case mcpinteraction.FieldAvailableTools:
		m.ResetAvailableTools()
		return nil
	case mcpinteraction.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case mcpinteraction.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown MCPInteraction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MCPInteractionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.session != nil {
		edges = append(edges, mcpinteraction.EdgeSession)
	}
	if m.stage != nil {
		edges = append(edges, mcpinteraction.EdgeStage)
	}
	if m.agent_execution != nil {
		edges = append(edges, mcpinteraction.EdgeAgentExecution)
	}
	if m.timeline_events != nil {
		edges = append(edges, mcpinteraction.EdgeTimelineEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MCPInteractionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mcpinteraction.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case mcpinteraction.EdgeStage:
		if id := m.stage; id != nil {
			return []ent.Value{*id}
		}
	case mcpinteraction.EdgeAgentExecution:
		if id := m.agent_execution; id != nil {
			return []ent.Value{*id}
		}
	case mcpinteraction.EdgeTimelineEvents:
		ids := make([]ent.Value, 0, len(m.timeline_events))
		for id := range m.timeline_events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MCPInteractionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtimeline_events != nil {
		edges = append(edges, mcpinteraction.EdgeTimelineEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MCPInteractionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mcpinteraction.EdgeTimelineEvents:
		ids := make([]ent.Value, 0, len(m.removedtimeline_events))
		for id := range m.removedtimeline_events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MCPInteractionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsession {
		edges = append(edges, mcpinteraction.EdgeSession)
	}
	if m.clearedstage {
		edges = append(edges, mcpinteraction.EdgeStage)
	}
	if m.clearedagent_execution {
		edges = append(edges, mcpinteraction.EdgeAgentExecution)
	}
	if m.clearedtimeline_events {
		edges = append(edges, mcpinteraction.EdgeTimelineEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MCPInteractionMutation) EdgeCleared(name string) bool {
	switch name {
	case mcpinteraction.EdgeSession:
		return m.clearedsession
	case mcpinteraction.EdgeStage:
		return m.clearedstage
	case mcpinteraction.EdgeAgentExecution:
		return m.clearedagent_execution
	case mcpinteraction.EdgeTimelineEvents:
		return m.clearedtimeline_events
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MCPInteractionMutation) ClearEdge(name string) error {
	switch name {
	case mcpinteraction.EdgeSession:
		m.ClearSession()
		return nil
	case mcpinteraction.EdgeStage:
		m.ClearStage()
		return nil
	case mcpinteraction.EdgeAgentExecution:
		m.ClearAgentExecution()
		return nil
	}
	return fmt.Errorf("unknown MCPInteraction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MCPInteractionMutation) ResetEdge(name string) error {
	switch name {
	case mcpinteraction.EdgeSession:
		m.ResetSession()
		return nil
	case mcpinteraction.EdgeStage:
		m.ResetStage()
		return nil
	case mcpinteraction.EdgeAgentExecution:
		m.ResetAgentExecution()
		return nil
	case mcpinteraction.EdgeTimelineEvents:
		m.ResetTimelineEvents()
		return nil
	}
	return fmt.Errorf("unknown MCPInteraction edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	sequence_number         *int
	addsequence_number      *int
	role                    *message.Role
	content                 *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	session                 *string
	clearedsession          bool
	stage                   *string
	clearedstage            bool
	agent_execution         *string
	clearedagent_execution  bool
	llm_interactions        map[string]struct{}
	removedllm_interactions map[string]struct{}
	clearedllm_interactions bool
	done                    bool
	oldValue                func(context.Context) (*Message, error)
	predicates              []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id string) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *MessageMutation) SetSessionID(s string) {
	m.session = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *MessageMutation) SessionID() (r string, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *MessageMutation) ResetSessionID() {
	m.session = nil
}

// SetStageID sets the "stage_id" field.
func (m *MessageMutation) SetStageID(s string) {
	m.stage = &s
}

// StageID returns the value of the "stage_id" field in the mutation.
func (m *MessageMutation) StageID() (r string, exists bool) {
	v := m.stage
	if v == nil {
		return
	}
	return *v, true
}

// OldStageID returns the old "stage_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldStageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStageID: %w", err)
	}
	return oldValue.StageID, nil
}

// ResetStageID resets all changes to the "stage_id" field.
func (m *MessageMutation) ResetStageID() {
	m.stage = nil
}

// SetExecutionID sets the "execution_id" field.
func (m *MessageMutation) SetExecutionID(s string) {
	m.agent_execution = &s
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *MessageMutation) ExecutionID() (r string, exists bool) {
	v := m.agent_execution
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldExecutionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *MessageMutation) ResetExecutionID() {
	m.agent_execution = nil
}

// SetSequenceNumber sets the "sequence_number" field.
func (m *MessageMutation) SetSequenceNumber(i int) {
	m.sequence_number = &i
	m.addsequence_number = nil
}

// SequenceNumber returns the value of the "sequence_number" field in the mutation.
func (m *MessageMutation) SequenceNumber() (r int, exists bool) {
	v := m.sequence_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceNumber returns the old "sequence_number" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSequenceNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequenceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequenceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceNumber: %w", err)
	}
	return oldValue.SequenceNumber, nil
}

// AddSequenceNumber adds i to the "sequence_number" field.
func (m *MessageMutation) AddSequenceNumber(i int) {
	if m.addsequence_number != nil {
		*m.addsequence_number += i
	} else {
		m.addsequence_number = &i
	}
}

// AddedSequenceNumber returns the value that was added to the "sequence_number" field in this mutation.
func (m *MessageMutation) AddedSequenceNumber() (r int, exists bool) {
	v := m.addsequence_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequenceNumber resets all changes to the "sequence_number" field.
func (m *MessageMutation) ResetSequenceNumber() {
	m.sequence_number = nil
	m.addsequence_number = nil
}

// SetRole sets the "role" field.
func (m *MessageMutation) SetRole(value message.Role) {
	m.role = &value
}

// Role returns the value of the "role" field in the mutation.
func (m *MessageMutation) Role() (r message.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldRole(ctx context.Context) (v message.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *MessageMutation) ResetRole() {
	m.role = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearSession clears the "session" edge to the AlertSession entity.
func (m *MessageMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[message.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the AlertSession entity was cleared.
func (m *MessageMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) SessionIDs() (ids []string) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *MessageMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// ClearStage clears the "stage" edge to the Stage entity.
func (m *MessageMutation) ClearStage() {
	m.clearedstage = true
	m.clearedFields[message.FieldStageID] = struct{}{}
}

// StageCleared reports if the "stage" edge to the Stage entity was cleared.
func (m *MessageMutation) StageCleared() bool {
	return m.clearedstage
}

// StageIDs returns the "stage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) StageIDs() (ids []string) {
	if id := m.stage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStage resets all changes to the "stage" edge.
func (m *MessageMutation) ResetStage() {
	m.stage = nil
	m.clearedstage = false
}

// SetAgentExecutionID sets the "agent_execution" edge to the AgentExecution entity by id.
func (m *MessageMutation) SetAgentExecutionID(id string) {
	m.agent_execution = &id
}

// ClearAgentExecution clears the "agent_execution" edge to the AgentExecution entity.
func (m *MessageMutation) ClearAgentExecution() {
	m.clearedagent_execution = true
	m.clearedFields[message.FieldExecutionID] = struct{}{}
}

// AgentExecutionCleared reports if the "agent_execution" edge to the AgentExecution entity was cleared.
func (m *MessageMutation) AgentExecutionCleared() bool {
	return m.clearedagent_execution
}

// AgentExecutionID returns the "agent_execution" edge ID in the mutation.
func (m *MessageMutation) AgentExecutionID() (id string, exists bool) {
	if m.agent_execution != nil {
		return *m.agent_execution, true
	}
	return
}

// AgentExecutionIDs returns the "agent_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentExecutionID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) AgentExecutionIDs() (ids []string) {
	if id := m.agent_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgentExecution resets all changes to the "agent_execution" edge.
func (m *MessageMutation) ResetAgentExecution() {
	m.agent_execution = nil
	m.clearedagent_execution = false
}

// AddLlmInteractionIDs adds the "llm_interactions" edge to the LLMInteraction entity by ids.
func (m *MessageMutation) AddLlmInteractionIDs(ids ...string) {
	if m.llm_interactions == nil {
		m.llm_interactions = make(map[string]struct{})
	}
	for i := range ids {
		m.llm_interactions[ids[i]] = struct{}{}
	}
}

// ClearLlmInteractions clears the "llm_interactions" edge to the LLMInteraction entity.
func (m *MessageMutation) ClearLlmInteractions() {
	m.clearedllm_interactions = true
}

// LlmInteractionsCleared reports if the "llm_interactions" edge to the LLMInteraction entity was cleared.
func (m *MessageMutation) LlmInteractionsCleared() bool {
	return m.clearedllm_interactions
}

// RemoveLlmInteractionIDs removes the "llm_interactions" edge to the LLMInteraction entity by IDs.
func (m *MessageMutation) RemoveLlmInteractionIDs(ids ...string) {
	if m.removedllm_interactions == nil {
		m.removedllm_interactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.llm_interactions, ids[i])
		m.removedllm_interactions[ids[i]] = struct{}{}
	}
}

// RemovedLlmInteractions returns the removed IDs of the "llm_interactions" edge to the LLMInteraction entity.
func (m *MessageMutation) RemovedLlmInteractionsIDs() (ids []string) {
	for id := range m.removedllm_interactions {
		ids = append(ids, id)
	}
	return
}

// LlmInteractionsIDs returns the "llm_interactions" edge IDs in the mutation.
func (m *MessageMutation) LlmInteractionsIDs() (ids []string) {
	for id := range m.llm_interactions {
		ids = append(ids, id)
	}
	return
}

// ResetLlmInteractions resets all changes to the "llm_interactions" edge.
func (m *MessageMutation) ResetLlmInteractions() {
	m.llm_interactions = nil
	m.clearedllm_interactions = false
	m.removedllm_interactions = nil
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.session != nil {
		fields = append(fields, message.FieldSessionID)
	}
	if m.stage != nil {
		fields = append(fields, message.FieldStageID)
	}
	if m.agent_execution != nil {
		fields = append(fields, message.FieldExecutionID)
	}
	if m.sequence_number != nil {
		fields = append(fields, message.FieldSequenceNumber)
	}
	if m.role != nil {
		fields = append(fields, message.FieldRole)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldSessionID:
		return m.SessionID()
	case message.FieldStageID:
		return m.StageID()
	case message.FieldExecutionID:
		return m.ExecutionID()
	case message.FieldSequenceNumber:
		return m.SequenceNumber()
	case message.FieldRole:
		return m.Role()
	case message.FieldContent:
		return m.Content()
	case message.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldSessionID:
		return m.OldSessionID(ctx)
	case message.FieldStageID:
		return m.OldStageID(ctx)
	case message.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case message.FieldSequenceNumber:
		return m.OldSequenceNumber(ctx)
	case message.FieldRole:
		return m.OldRole(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case message.FieldStageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStageID(v)
		return nil
	case message.FieldExecutionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case message.FieldSequenceNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceNumber(v)
		return nil
	case message.FieldRole:
		v, ok := value.(message.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	if m.addsequence_number != nil {
		fields = append(fields, message.FieldSequenceNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case message.FieldSequenceNumber:
		return m.AddedSequenceNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case message.FieldSequenceNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldSessionID:
		m.ResetSessionID()
		return nil
	case message.FieldStageID:
		m.ResetStageID()
		return nil
	case message.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case message.FieldSequenceNumber:
		m.ResetSequenceNumber()
		return nil
	case message.FieldRole:
		m.ResetRole()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.session != nil {
		edges = append(edges, message.EdgeSession)
	}
	if m.stage != nil {
		edges = append(edges, message.EdgeStage)
	}
	if m.agent_execution != nil {
		edges = append(edges, message.EdgeAgentExecution)
	}
	if m.llm_interactions != nil {
		edges = append(edges, message.EdgeLlmInteractions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeStage:
		if id := m.stage; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeAgentExecution:
		if id := m.agent_execution; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeLlmInteractions:
		ids := make([]ent.Value, 0, len(m.llm_interactions))
		for id := range m.llm_interactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedllm_interactions != nil {
		edges = append(edges, message.EdgeLlmInteractions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeLlmInteractions:
		ids := make([]ent.Value, 0, len(m.removedllm_interactions))
		for id := range m.removedllm_interactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsession {
		edges = append(edges, message.EdgeSession)
	}
	if m.clearedstage {
		edges = append(edges, message.EdgeStage)
	}
	if m.clearedagent_execution {
		edges = append(edges, message.EdgeAgentExecution)
	}
	if m.clearedllm_interactions {
		edges = append(edges, message.EdgeLlmInteractions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeSession:
		return m.clearedsession
	case message.EdgeStage:
		return m.clearedstage
	case message.EdgeAgentExecution:
		return m.clearedagent_execution
	case message.EdgeLlmInteractions:
		return m.clearedllm_interactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeSession:
		m.ClearSession()
		return nil
	case message.EdgeStage:
		m.ClearStage()
		return nil
	case message.EdgeAgentExecution:
		m.ClearAgentExecution()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeSession:
		m.ResetSession()
		return nil
	case message.EdgeStage:
		m.ResetStage()
		return nil
	case message.EdgeAgentExecution:
		m.ResetAgentExecution()
		return nil
	case message.EdgeLlmInteractions:
		m.ResetLlmInteractions()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// StageMutation represents an operation that mutates the Stage nodes in the graph.
type StageMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	stage_name               *string
	stage_index              *int
	addstage_index           *int
	expected_agent_count     *int
	addexpected_agent_count  *int
	parallel_type            *stage.ParallelType
	success_policy           *stage.SuccessPolicy
	status                   *stage.Status
	started_at               *time.Time
	completed_at             *time.Time
	duration_ms              *int
	addduration_ms           *int
	error_message            *string
	clearedFields            map[string]struct{}
	session                  *string
	clearedsession           bool
	agent_executions         map[string]struct{}
	removedagent_executions  map[string]struct{}
	clearedagent_executions  bool
	timeline_events          map[string]struct{}
	removedtimeline_events   map[string]struct{}
	clearedtimeline_events   bool
	messages                 map[string]struct{}
	removedmessages          map[string]struct{}
	clearedmessages          bool
	llm_interactions         map[string]struct{}
	removedllm_interactions  map[string]struct{}
	clearedllm_interactions  bool
	mcp_interactions         map[string]struct{}
	removedmcp_interactions  map[string]struct{}
	clearedmcp_interactions  bool
	chat                     *string
	clearedchat              bool
	chat_user_message        *string
	clearedchat_user_message bool
	done                     bool
	oldValue                 func(context.Context) (*Stage, error)
	predicates               []predicate.Stage
}

var _ ent.Mutation = (*StageMutation)(nil)

// stageOption allows management of the mutation configuration using functional options.
type stageOption func(*StageMutation)

// newStageMutation creates new mutation for the Stage entity.
func newStageMutation(c config, op Op, opts ...stageOption) *StageMutation {
	m := &StageMutation{
		config:        c,
		op:            op,
		typ:           TypeStage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStageID sets the ID field of the mutation.
func withStageID(id string) stageOption {
	return func(m *StageMutation) {
		var (
			err   error
			once  sync.Once
			value *Stage
		)
		m.oldValue = func(ctx context.Context) (*Stage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStage sets the old Stage of the mutation.
func withStage(node *Stage) stageOption {
	return func(m *StageMutation) {
		m.oldValue = func(context.Context) (*Stage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stage entities.
func (m *StageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *StageMutation) SetSessionID(s string) {
	m.session = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *StageMutation) SessionID() (r string, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *StageMutation) ResetSessionID() {
	m.session = nil
}

// SetStageName sets the "stage_name" field.
func (m *StageMutation) SetStageName(s string) {
	m.stage_name = &s
}

// StageName returns the value of the "stage_name" field in the mutation.
func (m *StageMutation) StageName() (r string, exists bool) {
	v := m.stage_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStageName returns the old "stage_name" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldStageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStageName: %w", err)
	}
	return oldValue.StageName, nil
}

// ResetStageName resets all changes to the "stage_name" field.
func (m *StageMutation) ResetStageName() {
	m.stage_name = nil
}

// SetStageIndex sets the "stage_index" field.
func (m *StageMutation) SetStageIndex(i int) {
	m.stage_index = &i
	m.addstage_index = nil
}

// StageIndex returns the value of the "stage_index" field in the mutation.
func (m *StageMutation) StageIndex() (r int, exists bool) {
	v := m.stage_index
	if v == nil {
		return
	}
	return *v, true
}

// OldStageIndex returns the old "stage_index" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldStageIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStageIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStageIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStageIndex: %w", err)
	}
	return oldValue.StageIndex, nil
}

// AddStageIndex adds i to the "stage_index" field.
func (m *StageMutation) AddStageIndex(i int) {
	if m.addstage_index != nil {
		*m.addstage_index += i
	} else {
		m.addstage_index = &i
	}
}

// AddedStageIndex returns the value that was added to the "stage_index" field in this mutation.
func (m *StageMutation) AddedStageIndex() (r int, exists bool) {
	v := m.addstage_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetStageIndex resets all changes to the "stage_index" field.
func (m *StageMutation) ResetStageIndex() {
	m.stage_index = nil
	m.addstage_index = nil
}

// SetExpectedAgentCount sets the "expected_agent_count" field.
func (m *StageMutation) SetExpectedAgentCount(i int) {
	m.expected_agent_count = &i
	m.addexpected_agent_count = nil
}

// ExpectedAgentCount returns the value of the "expected_agent_count" field in the mutation.
func (m *StageMutation) ExpectedAgentCount() (r int, exists bool) {
	v := m.expected_agent_count
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedAgentCount returns the old "expected_agent_count" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldExpectedAgentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectedAgentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectedAgentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedAgentCount: %w", err)
	}
	return oldValue.ExpectedAgentCount, nil
}

// AddExpectedAgentCount adds i to the "expected_agent_count" field.
func (m *StageMutation) AddExpectedAgentCount(i int) {
	if m.addexpected_agent_count != nil {
		*m.addexpected_agent_count += i
	} else {
		m.addexpected_agent_count = &i
	}
}

// AddedExpectedAgentCount returns the value that was added to the "expected_agent_count" field in this mutation.
func (m *StageMutation) AddedExpectedAgentCount() (r int, exists bool) {
	v := m.addexpected_agent_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetExpectedAgentCount resets all changes to the "expected_agent_count" field.
func (m *StageMutation) ResetExpectedAgentCount() {
	m.expected_agent_count = nil
	m.addexpected_agent_count = nil
}

// SetParallelType sets the "parallel_type" field.
func (m *StageMutation) SetParallelType(st stage.ParallelType) {
	m.parallel_type = &st
}

// ParallelType returns the value of the "parallel_type" field in the mutation.
func (m *StageMutation) ParallelType() (r stage.ParallelType, exists bool) {
	v := m.parallel_type
	if v == nil {
		return
	}
	return *v, true
}

// OldParallelType returns the old "parallel_type" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldParallelType(ctx context.Context) (v *stage.ParallelType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParallelType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParallelType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParallelType: %w", err)
	}
	return oldValue.ParallelType, nil
}

// ClearParallelType clears the value of the "parallel_type" field.
func (m *StageMutation) ClearParallelType() {
	m.parallel_type = nil
	m.clearedFields[stage.FieldParallelType] = struct{}{}
}

// ParallelTypeCleared returns if the "parallel_type" field was cleared in this mutation.
func (m *StageMutation) ParallelTypeCleared() bool {
	_, ok := m.clearedFields[stage.FieldParallelType]
	return ok
}

// ResetParallelType resets all changes to the "parallel_type" field.
func (m *StageMutation) ResetParallelType() {
	m.parallel_type = nil
	delete(m.clearedFields, stage.FieldParallelType)
}

// SetSuccessPolicy sets the "success_policy" field.
func (m *StageMutation) SetSuccessPolicy(sp stage.SuccessPolicy) {
	m.success_policy = &sp
}

// SuccessPolicy returns the value of the "success_policy" field in the mutation.
func (m *StageMutation) SuccessPolicy() (r stage.SuccessPolicy, exists bool) {
	v := m.success_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessPolicy returns the old "success_policy" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldSuccessPolicy(ctx context.Context) (v *stage.SuccessPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccessPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccessPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessPolicy: %w", err)
	}
	return oldValue.SuccessPolicy, nil
}

// ClearSuccessPolicy clears the value of the "success_policy" field.
func (m *StageMutation) ClearSuccessPolicy() {
	m.success_policy = nil
	m.clearedFields[stage.FieldSuccessPolicy] = struct{}{}
}

// SuccessPolicyCleared returns if the "success_policy" field was cleared in this mutation.
func (m *StageMutation) SuccessPolicyCleared() bool {
	_, ok := m.clearedFields[stage.FieldSuccessPolicy]
	return ok
}

// ResetSuccessPolicy resets all changes to the "success_policy" field.
func (m *StageMutation) ResetSuccessPolicy() {
	m.success_policy = nil
	delete(m.clearedFields, stage.FieldSuccessPolicy)
}

// SetStatus sets the "status" field.
func (m *StageMutation) SetStatus(s stage.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StageMutation) Status() (r stage.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldStatus(ctx context.Context) (v stage.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StageMutation) ResetStatus() {
	m.status = nil
}

// SetStartedAt sets the "started_at" field.
func (m *StageMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *StageMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *StageMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[stage.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *StageMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[stage.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *StageMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, stage.FieldStartedAt)
}

// SetCompletedAt sets the "completed_at" field.
func (m *StageMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *StageMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *StageMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[stage.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *StageMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[stage.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *StageMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, stage.FieldCompletedAt)
}

// SetDurationMs sets the "duration_ms" field.
func (m *StageMutation) SetDurationMs(i int) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *StageMutation) DurationMs() (r int, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldDurationMs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *StageMutation) AddDurationMs(i int) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *StageMutation) AddedDurationMs() (r int, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *StageMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[stage.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *StageMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[stage.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *StageMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, stage.FieldDurationMs)
}

// SetErrorMessage sets the "error_message" field.
func (m *StageMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *StageMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *StageMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[stage.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *StageMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[stage.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *StageMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, stage.FieldErrorMessage)
}

// SetChatID sets the "chat_id" field.
func (m *StageMutation) SetChatID(s string) {
	m.chat = &s
}

// ChatID returns the value of the "chat_id" field in the mutation.
func (m *StageMutation) ChatID() (r string, exists bool) {
	v := m.chat
	if v == nil {
		return
	}
	return *v, true
}

// OldChatID returns the old "chat_id" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldChatID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatID: %w", err)
	}
	return oldValue.ChatID, nil
}

// ClearChatID clears the value of the "chat_id" field.
func (m *StageMutation) ClearChatID() {
	m.chat = nil
	m.clearedFields[stage.FieldChatID] = struct{}{}
}

// ChatIDCleared returns if the "chat_id" field was cleared in this mutation.
func (m *StageMutation) ChatIDCleared() bool {
	_, ok := m.clearedFields[stage.FieldChatID]
	return ok
}

// ResetChatID resets all changes to the "chat_id" field.
func (m *StageMutation) ResetChatID() {
	m.chat = nil
	delete(m.clearedFields, stage.FieldChatID)
}

// SetChatUserMessageID sets the "chat_user_message_id" field.
func (m *StageMutation) SetChatUserMessageID(s string) {
	m.chat_user_message = &s
}

// ChatUserMessageID returns the value of the "chat_user_message_id" field in the mutation.
func (m *StageMutation) ChatUserMessageID() (r string, exists bool) {
	v := m.chat_user_message
	if v == nil {
		return
	}
	return *v, true
}

// OldChatUserMessageID returns the old "chat_user_message_id" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldChatUserMessageID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatUserMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatUserMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatUserMessageID: %w", err)
	}
	return oldValue.ChatUserMessageID, nil
}

// ClearChatUserMessageID clears the value of the "chat_user_message_id" field.
func (m *StageMutation) ClearChatUserMessageID() {
	m.chat_user_message = nil
	m.clearedFields[stage.FieldChatUserMessageID] = struct{}{}
}

// ChatUserMessageIDCleared returns if the "chat_user_message_id" field was cleared in this mutation.
func (m *StageMutation) ChatUserMessageIDCleared() bool {
	_, ok := m.clearedFields[stage.FieldChatUserMessageID]
	return ok
}

// ResetChatUserMessageID resets all changes to the "chat_user_message_id" field.
func (m *StageMutation) ResetChatUserMessageID() {
	m.chat_user_message = nil
	delete(m.clearedFields, stage.FieldChatUserMessageID)
}

// ClearSession clears the "session" edge to the AlertSession entity.
func (m *StageMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[stage.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the AlertSession entity was cleared.
func (m *StageMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *StageMutation) SessionIDs() (ids []string) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *StageMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// AddAgentExecutionIDs adds the "agent_executions" edge to the AgentExecution entity by ids.
func (m *StageMutation) AddAgentExecutionIDs(ids ...string) {
	if m.agent_executions == nil {
		m.agent_executions = make(map[string]struct{})
	}
	for i := range ids {
		m.agent_executions[ids[i]] = struct{}{}
	}
}

// ClearAgentExecutions clears the "agent_executions" edge to the AgentExecution entity.
func (m *StageMutation) ClearAgentExecutions() {
	m.clearedagent_executions = true
}

// AgentExecutionsCleared reports if the "agent_executions" edge to the AgentExecution entity was cleared.
func (m *StageMutation) AgentExecutionsCleared() bool {
	return m.clearedagent_executions
}

// RemoveAgentExecutionIDs removes the "agent_executions" edge to the AgentExecution entity by IDs.
func (m *StageMutation) RemoveAgentExecutionIDs(ids ...string) {
	if m.removedagent_executions == nil {
		m.removedagent_executions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.agent_executions, ids[i])
		m.removedagent_executions[ids[i]] = struct{}{}
	}
}

// RemovedAgentExecutions returns the removed IDs of the "agent_executions" edge to the AgentExecution entity.
func (m *StageMutation) RemovedAgentExecutionsIDs() (ids []string) {
	for id := range m.removedagent_executions {
		ids = append(ids, id)
	}
	return
}

// AgentExecutionsIDs returns the "agent_executions" edge IDs in the mutation.
func (m *StageMutation) AgentExecutionsIDs() (ids []string) {
	for id := range m.agent_executions {
		ids = append(ids, id)
	}
	return
}

// ResetAgentExecutions resets all changes to the "agent_executions" edge.
func (m *StageMutation) ResetAgentExecutions() {
	m.agent_executions = nil
	m.clearedagent_executions = false
	m.removedagent_executions = nil
}

// AddTimelineEventIDs adds the "timeline_events" edge to the TimelineEvent entity by ids.
func (m *StageMutation) AddTimelineEventIDs(ids ...string) {
	if m.timeline_events == nil {
		m.timeline_events = make(map[string]struct{})
	}
	for i := range ids {
		m.timeline_events[ids[i]] = struct{}{}
	}
}

// ClearTimelineEvents clears the "timeline_events" edge to the TimelineEvent entity.
func (m *StageMutation) ClearTimelineEvents() {
	m.clearedtimeline_events = true
}

// TimelineEventsCleared reports if the "timeline_events" edge to the TimelineEvent entity was cleared.
func (m *StageMutation) TimelineEventsCleared() bool {
	return m.clearedtimeline_events
}

// RemoveTimelineEventIDs removes the "timeline_events" edge to the TimelineEvent entity by IDs.
func (m *StageMutation) RemoveTimelineEventIDs(ids ...string) {
	if m.removedtimeline_events == nil {
		m.removedtimeline_events = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.timeline_events, ids[i])
		m.removedtimeline_events[ids[i]] = struct{}{}
	}
}

// RemovedTimelineEvents returns the removed IDs of the "timeline_events" edge to the TimelineEvent entity.
func (m *StageMutation) RemovedTimelineEventsIDs() (ids []string) {
	for id := range m.removedtimeline_events {
		ids = append(ids, id)
	}
	return
}

// TimelineEventsIDs returns the "timeline_events" edge IDs in the mutation.
func (m *StageMutation) TimelineEventsIDs() (ids []string) {
	for id := range m.timeline_events {
		ids = append(ids, id)
	}
	return
}

// ResetTimelineEvents resets all changes to the "timeline_events" edge.
func (m *StageMutation) ResetTimelineEvents() {
	m.timeline_events = nil
	m.clearedtimeline_events = false
	m.removedtimeline_events = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *StageMutation) AddMessageIDs(ids ...string) {
	if m.messages == nil {
		m.messages = make(map[string]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *StageMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *StageMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *StageMutation) RemoveMessageIDs(ids ...string) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *StageMutation) RemovedMessagesIDs() (ids []string) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *StageMutation) MessagesIDs() (ids []string) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *StageMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddLlmInteractionIDs adds the "llm_interactions" edge to the LLMInteraction entity by ids.
func (m *StageMutation) AddLlmInteractionIDs(ids ...string) {
	if m.llm_interactions == nil {
		m.llm_interactions = make(map[string]struct{})
	}
	for i := range ids {
		m.llm_interactions[ids[i]] = struct{}{}
	}
}

// ClearLlmInteractions clears the "llm_interactions" edge to the LLMInteraction entity.
func (m *StageMutation) ClearLlmInteractions() {
	m.clearedllm_interactions = true
}

// LlmInteractionsCleared reports if the "llm_interactions" edge to the LLMInteraction entity was cleared.
func (m *StageMutation) LlmInteractionsCleared() bool {
	return m.clearedllm_interactions
}

// RemoveLlmInteractionIDs removes the "llm_interactions" edge to the LLMInteraction entity by IDs.
func (m *StageMutation) RemoveLlmInteractionIDs(ids ...string) {
	if m.removedllm_interactions == nil {
		m.removedllm_interactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.llm_interactions, ids[i])
		m.removedllm_interactions[ids[i]] = struct{}{}
	}
}

// RemovedLlmInteractions returns the removed IDs of the "llm_interactions" edge to the LLMInteraction entity.
func (m *StageMutation) RemovedLlmInteractionsIDs() (ids []string) {
	for id := range m.removedllm_interactions {
		ids = append(ids, id)
	}
	return
}

// LlmInteractionsIDs returns the "llm_interactions" edge IDs in the mutation.
func (m *StageMutation) LlmInteractionsIDs() (ids []string) {
	for id := range m.llm_interactions {
		ids = append(ids, id)
	}
	return
}

// ResetLlmInteractions resets all changes to the "llm_interactions" edge.
func (m *StageMutation) ResetLlmInteractions() {
	m.llm_interactions = nil
	m.clearedllm_interactions = false
	m.removedllm_interactions = nil
}

// AddMcpInteractionIDs adds the "mcp_interactions" edge to the MCPInteraction entity by ids.
func (m *StageMutation) AddMcpInteractionIDs(ids ...string) {
	if m.mcp_interactions == nil {
		m.mcp_interactions = make(map[string]struct{})
	}
	for i := range ids {
		m.mcp_interactions[ids[i]] = struct{}{}
	}
}

// ClearMcpInteractions clears the "mcp_interactions" edge to the MCPInteraction entity.
func (m *StageMutation) ClearMcpInteractions() {
	m.clearedmcp_interactions = true
}

// McpInteractionsCleared reports if the "mcp_interactions" edge to the MCPInteraction entity was cleared.
func (m *StageMutation) McpInteractionsCleared() bool {
	return m.clearedmcp_interactions
}

// RemoveMcpInteractionIDs removes the "mcp_interactions" edge to the MCPInteraction entity by IDs.
func (m *StageMutation) RemoveMcpInteractionIDs(ids ...string) {
	if m.removedmcp_interactions == nil {
		m.removedmcp_interactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.mcp_interactions, ids[i])
		m.removedmcp_interactions[ids[i]] = struct{}{}
	}
}

// RemovedMcpInteractions returns the removed IDs of the "mcp_interactions" edge to the MCPInteraction entity.
func (m *StageMutation) RemovedMcpInteractionsIDs() (ids []string) {
	for id := range m.removedmcp_interactions {
		ids = append(ids, id)
	}
	return
}

// McpInteractionsIDs returns the "mcp_interactions" edge IDs in the mutation.
func (m *StageMutation) McpInteractionsIDs() (ids []string) {
	for id := range m.mcp_interactions {
		ids = append(ids, id)
	}
	return
}

// ResetMcpInteractions resets all changes to the "mcp_interactions" edge.
func (m *StageMutation) ResetMcpInteractions() {
	m.mcp_interactions = nil
	m.clearedmcp_interactions = false
	m.removedmcp_interactions = nil
}

// ClearChat clears the "chat" edge to the Chat entity.
func (m *StageMutation) ClearChat() {
	m.clearedchat = true
	m.clearedFields[stage.FieldChatID] = struct{}{}
}

// ChatCleared reports if the "chat" edge to the Chat entity was cleared.
func (m *StageMutation) ChatCleared() bool {
	return m.ChatIDCleared() || m.clearedchat
}

// ChatIDs returns the "chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChatID instead. It exists only for internal usage by the builders.
func (m *StageMutation) ChatIDs() (ids []string) {
	if id := m.chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChat resets all changes to the "chat" edge.
func (m *StageMutation) ResetChat() {
	m.chat = nil
	m.clearedchat = false
}

// ClearChatUserMessage clears the "chat_user_message" edge to the ChatUserMessage entity.
func (m *StageMutation) ClearChatUserMessage() {
	m.clearedchat_user_message = true
	m.clearedFields[stage.FieldChatUserMessageID] = struct{}{}
}

// ChatUserMessageCleared reports if the "chat_user_message" edge to the ChatUserMessage entity was cleared.
func (m *StageMutation) ChatUserMessageCleared() bool {
	return m.ChatUserMessageIDCleared() || m.clearedchat_user_message
}

// ChatUserMessageIDs returns the "chat_user_message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChatUserMessageID instead. It exists only for internal usage by the builders.
func (m *StageMutation) ChatUserMessageIDs() (ids []string) {
	if id := m.chat_user_message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChatUserMessage resets all changes to the "chat_user_message" edge.
func (m *StageMutation) ResetChatUserMessage() {
	m.chat_user_message = nil
	m.clearedchat_user_message = false
}

// Where appends a list predicates to the StageMutation builder.
func (m *StageMutation) Where(ps ...predicate.Stage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Stage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Stage).
func (m *StageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StageMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.session != nil {
		fields = append(fields, stage.FieldSessionID)
	}
	if m.stage_name != nil {
		fields = append(fields, stage.FieldStageName)
	}
	if m.stage_index != nil {
		fields = append(fields, stage.FieldStageIndex)
	}
	if m.expected_agent_count != nil {
		fields = append(fields, stage.FieldExpectedAgentCount)
	}
	if m.parallel_type != nil {
		fields = append(fields, stage.FieldParallelType)
	}
	if m.success_policy != nil {
		fields = append(fields, stage.FieldSuccessPolicy)
	}
	if m.status != nil {
		fields = append(fields, stage.FieldStatus)
	}
	if m.started_at != nil {
		fields = append(fields, stage.FieldStartedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, stage.FieldCompletedAt)
	}
	if m.duration_ms != nil {
		fields = append(fields, stage.FieldDurationMs)
	}
	if m.error_message != nil {
		fields = append(fields, stage.FieldErrorMessage)
	}
	if m.chat != nil {
		fields = append(fields, stage.FieldChatID)
	}
	if m.chat_user_message != nil {
		fields = append(fields, stage.FieldChatUserMessageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stage.FieldSessionID:
		return m.SessionID()
	case stage.FieldStageName:
		return m.StageName()
	case stage.FieldStageIndex:
		return m.StageIndex()
	case stage.FieldExpectedAgentCount:
		return m.ExpectedAgentCount()
	case stage.FieldParallelType:
		return m.ParallelType()
	case stage.FieldSuccessPolicy:
		return m.SuccessPolicy()
	case stage.FieldStatus:
		return m.Status()
	case stage.FieldStartedAt:
		return m.StartedAt()
	case stage.FieldCompletedAt:
		return m.CompletedAt()
	case stage.FieldDurationMs:
		return m.DurationMs()
	case stage.FieldErrorMessage:
		return m.ErrorMessage()
	case stage.FieldChatID:
		return m.ChatID()
	case stage.FieldChatUserMessageID:
		return m.ChatUserMessageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stage.FieldSessionID:
		return m.OldSessionID(ctx)
	case stage.FieldStageName:
		return m.OldStageName(ctx)
	case stage.FieldStageIndex:
		return m.OldStageIndex(ctx)
	case stage.FieldExpectedAgentCount:
		return m.OldExpectedAgentCount(ctx)
	case stage.FieldParallelType:
		return m.OldParallelType(ctx)
	case stage.FieldSuccessPolicy:
		return m.OldSuccessPolicy(ctx)
	case stage.FieldStatus:
		return m.OldStatus(ctx)
	case stage.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case stage.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case stage.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case stage.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case stage.FieldChatID:
		return m.OldChatID(ctx)
	case stage.FieldChatUserMessageID:
		return m.OldChatUserMessageID(ctx)
	}
	return nil, fmt.Errorf("unknown Stage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stage.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case stage.FieldStageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStageName(v)
		return nil
	case stage.FieldStageIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStageIndex(v)
		return nil
	case stage.FieldExpectedAgentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedAgentCount(v)
		return nil
	case stage.FieldParallelType:
		v, ok := value.(stage.ParallelType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParallelType(v)
		return nil
	case stage.FieldSuccessPolicy:
		v, ok := value.(stage.SuccessPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessPolicy(v)
		return nil
	case stage.FieldStatus:
		v, ok := value.(stage.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case stage.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case stage.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case stage.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case stage.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case stage.FieldChatID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatID(v)
		return nil
	case stage.FieldChatUserMessageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatUserMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown Stage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StageMutation) AddedFields() []string {
	var fields []string
	if m.addstage_index != nil {
		fields = append(fields, stage.FieldStageIndex)
	}
	if m.addexpected_agent_count != nil {
		fields = append(fields, stage.FieldExpectedAgentCount)
	}
	if m.addduration_ms != nil {
		fields = append(fields, stage.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stage.FieldStageIndex:
		return m.AddedStageIndex()
	case stage.FieldExpectedAgentCount:
		return m.AddedExpectedAgentCount()
	case stage.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stage.FieldStageIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStageIndex(v)
		return nil
	case stage.FieldExpectedAgentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpectedAgentCount(v)
		return nil
	case stage.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown Stage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stage.FieldParallelType) {
		fields = append(fields, stage.FieldParallelType)
	}
	if m.FieldCleared(stage.FieldSuccessPolicy) {
		fields = append(fields, stage.FieldSuccessPolicy)
	}
	if m.FieldCleared(stage.FieldStartedAt) {
		fields = append(fields, stage.FieldStartedAt)
	}
	if m.FieldCleared(stage.FieldCompletedAt) {
		fields = append(fields, stage.FieldCompletedAt)
	}
	if m.FieldCleared(stage.FieldDurationMs) {
		fields = append(fields, stage.FieldDurationMs)
	}
	if m.FieldCleared(stage.FieldErrorMessage) {
		fields = append(fields, stage.FieldErrorMessage)
	}
	if m.FieldCleared(stage.FieldChatID) {
		fields = append(fields, stage.FieldChatID)
	}
	if m.FieldCleared(stage.FieldChatUserMessageID) {
		fields = append(fields, stage.FieldChatUserMessageID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StageMutation) ClearField(name string) error {
	switch name {
	case stage.FieldParallelType:
		m.ClearParallelType()
		return nil
	case stage.FieldSuccessPolicy:
		m.ClearSuccessPolicy()
		return nil
	case stage.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case stage.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case stage.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	case stage.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case stage.FieldChatID:
		m.ClearChatID()
		return nil
	case stage.FieldChatUserMessageID:
		m.ClearChatUserMessageID()
		return nil
	}
	return fmt.Errorf("unknown Stage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StageMutation) ResetField(name string) error {
	switch name {
	case stage.FieldSessionID:
		m.ResetSessionID()
		return nil
	case stage.FieldStageName:
		m.ResetStageName()
		return nil
	case stage.FieldStageIndex:
		m.ResetStageIndex()
		return nil
	case stage.FieldExpectedAgentCount:
		m.ResetExpectedAgentCount()
		return nil
	case stage.FieldParallelType:
		m.ResetParallelType()
		return nil
	case stage.FieldSuccessPolicy:
		m.ResetSuccessPolicy()
		return nil
	case stage.FieldStatus:
		m.ResetStatus()
		return nil
	case stage.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case stage.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case stage.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case stage.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case stage.FieldChatID:
		m.ResetChatID()
		return nil
	case stage.FieldChatUserMessageID:
		m.ResetChatUserMessageID()
		return nil
	}
	return fmt.Errorf("unknown Stage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StageMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.session != nil {
		edges = append(edges, stage.EdgeSession)
	}
	if m.agent_executions != nil {
		edges = append(edges, stage.EdgeAgentExecutions)
	}
	if m.timeline_events != nil {
		edges = append(edges, stage.EdgeTimelineEvents)
	}
	if m.messages != nil {
		edges = append(edges, stage.EdgeMessages)
	}
	if m.llm_interactions != nil {
		edges = append(edges, stage.EdgeLlmInteractions)
	}
	if m.mcp_interactions != nil {
		edges = append(edges, stage.EdgeMcpInteractions)
	}
	if m.chat != nil {
		edges = append(edges, stage.EdgeChat)
	}
	if m.chat_user_message != nil {
		edges = append(edges, stage.EdgeChatUserMessage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stage.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case stage.EdgeAgentExecutions:
		ids := make([]ent.Value, 0, len(m.agent_executions))
		for id := range m.agent_executions {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgeTimelineEvents:
		ids := make([]ent.Value, 0, len(m.timeline_events))
		for id := range m.timeline_events {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgeLlmInteractions:
		ids := make([]ent.Value, 0, len(m.llm_interactions))
		for id := range m.llm_interactions {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgeMcpInteractions:
		ids := make([]ent.Value, 0, len(m.mcp_interactions))
		for id := range m.mcp_interactions {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgeChat:
		if id := m.chat; id != nil {
			return []ent.Value{*id}
		}
	case stage.EdgeChatUserMessage:
		if id := m.chat_user_message; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedagent_executions != nil {
		edges = append(edges, stage.EdgeAgentExecutions)
	}
	if m.removedtimeline_events != nil {
		edges = append(edges, stage.EdgeTimelineEvents)
	}
	if m.removedmessages != nil {
		edges = append(edges, stage.EdgeMessages)
	}
	if m.removedllm_interactions != nil {
		edges = append(edges, stage.EdgeLlmInteractions)
	}
	if m.removedmcp_interactions != nil {
		edges = append(edges, stage.EdgeMcpInteractions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case stage.EdgeAgentExecutions:
		ids := make([]ent.Value, 0, len(m.removedagent_executions))
		for id := range m.removedagent_executions {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgeTimelineEvents:
		ids := make([]ent.Value, 0, len(m.removedtimeline_events))
		for id := range m.removedtimeline_events {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgeLlmInteractions:
		ids := make([]ent.Value, 0, len(m.removedllm_interactions))
		for id := range m.removedllm_interactions {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgeMcpInteractions:
		ids := make([]ent.Value, 0, len(m.removedmcp_interactions))
		for id := range m.removedmcp_interactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedsession {
		edges = append(edges, stage.EdgeSession)
	}
	if m.clearedagent_executions {
		edges = append(edges, stage.EdgeAgentExecutions)
	}
	if m.clearedtimeline_events {
		edges = append(edges, stage.EdgeTimelineEvents)
	}
	if m.clearedmessages {
		edges = append(edges, stage.EdgeMessages)
	}
	if m.clearedllm_interactions {
		edges = append(edges, stage.EdgeLlmInteractions)
	}
	if m.clearedmcp_interactions {
		edges = append(edges, stage.EdgeMcpInteractions)
	}
	if m.clearedchat {
		edges = append(edges, stage.EdgeChat)
	}
	if m.clearedchat_user_message {
		edges = append(edges, stage.EdgeChatUserMessage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StageMutation) EdgeCleared(name string) bool {
	switch name {
	case stage.EdgeSession:
		return m.clearedsession
	case stage.EdgeAgentExecutions:
		return m.clearedagent_executions
	case stage.EdgeTimelineEvents:
		return m.clearedtimeline_events
	case stage.EdgeMessages:
		return m.clearedmessages
	case stage.EdgeLlmInteractions:
		return m.clearedllm_interactions
	case stage.EdgeMcpInteractions:
		return m.clearedmcp_interactions
	case stage.EdgeChat:
		return m.clearedchat
	case stage.EdgeChatUserMessage:
		return m.clearedchat_user_message
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StageMutation) ClearEdge(name string) error {
	switch name {
	case stage.EdgeSession:
		m.ClearSession()
		return nil
	case stage.EdgeChat:
		m.ClearChat()
		return nil
	case stage.EdgeChatUserMessage:
		m.ClearChatUserMessage()
		return nil
	}
	return fmt.Errorf("unknown Stage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StageMutation) ResetEdge(name string) error {
	switch name {
	case stage.EdgeSession:
		m.ResetSession()
		return nil
	case stage.EdgeAgentExecutions:
		m.ResetAgentExecutions()
		return nil
	case stage.EdgeTimelineEvents:
		m.ResetTimelineEvents()
		return nil
	case stage.EdgeMessages:
		m.ResetMessages()
		return nil
	case stage.EdgeLlmInteractions:
		m.ResetLlmInteractions()
		return nil
	case stage.EdgeMcpInteractions:
		m.ResetMcpInteractions()
		return nil
	case stage.EdgeChat:
		m.ResetChat()
		return nil
	case stage.EdgeChatUserMessage:
		m.ResetChatUserMessage()
		return nil
	}
	return fmt.Errorf("unknown Stage edge %s", name)
}

// TimelineEventMutation represents an operation that mutates the TimelineEvent nodes in the graph.
type TimelineEventMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	sequence_number        *int
	addsequence_number     *int
	created_at             *time.Time
	updated_at             *time.Time
	event_type             *timelineevent.EventType
	status                 *timelineevent.Status
	content                *string
	metadata               *map[string]interface{}
	clearedFields          map[string]struct{}
	session                *string
	clearedsession         bool
	stage                  *string
	clearedstage           bool
	agent_execution        *string
	clearedagent_execution bool
	llm_interaction        *string
	clearedllm_interaction bool
	mcp_interaction        *string
	clearedmcp_interaction bool
	done                   bool
	oldValue               func(context.Context) (*TimelineEvent, error)
	predicates             []predicate.TimelineEvent
}

var _ ent.Mutation = (*TimelineEventMutation)(nil)

// timelineeventOption allows management of the mutation configuration using functional options.
type timelineeventOption func(*TimelineEventMutation)

// newTimelineEventMutation creates new mutation for the TimelineEvent entity.
func newTimelineEventMutation(c config, op Op, opts ...timelineeventOption) *TimelineEventMutation {
	m := &TimelineEventMutation{
		config:        c,
		op:            op,
		typ:           TypeTimelineEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimelineEventID sets the ID field of the mutation.
func withTimelineEventID(id string) timelineeventOption {
	return func(m *TimelineEventMutation) {
		var (
			err   error
			once  sync.Once
			value *TimelineEvent
		)
		m.oldValue = func(ctx context.Context) (*TimelineEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimelineEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimelineEvent sets the old TimelineEvent of the mutation.
func withTimelineEvent(node *TimelineEvent) timelineeventOption {
	return func(m *TimelineEventMutation) {
		m.oldValue = func(context.Context) (*TimelineEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimelineEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimelineEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TimelineEvent entities.
func (m *TimelineEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimelineEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimelineEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimelineEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *TimelineEventMutation) SetSessionID(s string) {
	m.session = &s
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *TimelineEventMutation) SessionID() (r string, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *TimelineEventMutation) ResetSessionID() {
	m.session = nil
}

// SetStageID sets the "stage_id" field.
func (m *TimelineEventMutation) SetStageID(s string) {
	m.stage = &s
}

// StageID returns the value of the "stage_id" field in the mutation.
func (m *TimelineEventMutation) StageID() (r string, exists bool) {
	v := m.stage
	if v == nil {
		return
	}
	return *v, true
}

// OldStageID returns the old "stage_id" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldStageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStageID: %w", err)
	}
	return oldValue.StageID, nil
}

// ResetStageID resets all changes to the "stage_id" field.
func (m *TimelineEventMutation) ResetStageID() {
	m.stage = nil
}

// SetExecutionID sets the "execution_id" field.
func (m *TimelineEventMutation) SetExecutionID(s string) {
	m.agent_execution = &s
}

// ExecutionID returns the value of the "execution_id" field in the mutation.
func (m *TimelineEventMutation) ExecutionID() (r string, exists bool) {
	v := m.agent_execution
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionID returns the old "execution_id" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldExecutionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionID: %w", err)
	}
	return oldValue.ExecutionID, nil
}

// ResetExecutionID resets all changes to the "execution_id" field.
func (m *TimelineEventMutation) ResetExecutionID() {
	m.agent_execution = nil
}

// SetSequenceNumber sets the "sequence_number" field.
func (m *TimelineEventMutation) SetSequenceNumber(i int) {
	m.sequence_number = &i
	m.addsequence_number = nil
}

// SequenceNumber returns the value of the "sequence_number" field in the mutation.
func (m *TimelineEventMutation) SequenceNumber() (r int, exists bool) {
	v := m.sequence_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSequenceNumber returns the old "sequence_number" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldSequenceNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequenceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequenceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequenceNumber: %w", err)
	}
	return oldValue.SequenceNumber, nil
}

// AddSequenceNumber adds i to the "sequence_number" field.
func (m *TimelineEventMutation) AddSequenceNumber(i int) {
	if m.addsequence_number != nil {
		*m.addsequence_number += i
	} else {
		m.addsequence_number = &i
	}
}

// AddedSequenceNumber returns the value that was added to the "sequence_number" field in this mutation.
func (m *TimelineEventMutation) AddedSequenceNumber() (r int, exists bool) {
	v := m.addsequence_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequenceNumber resets all changes to the "sequence_number" field.
func (m *TimelineEventMutation) ResetSequenceNumber() {
	m.sequence_number = nil
	m.addsequence_number = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TimelineEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TimelineEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TimelineEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TimelineEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TimelineEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TimelineEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEventType sets the "event_type" field.
func (m *TimelineEventMutation) SetEventType(tt timelineevent.EventType) {
	m.event_type = &tt
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *TimelineEventMutation) EventType() (r timelineevent.EventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldEventType(ctx context.Context) (v timelineevent.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *TimelineEventMutation) ResetEventType() {
	m.event_type = nil
}

// SetStatus sets the "status" field.
func (m *TimelineEventMutation) SetStatus(t timelineevent.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TimelineEventMutation) Status() (r timelineevent.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldStatus(ctx context.Context) (v timelineevent.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TimelineEventMutation) ResetStatus() {
	m.status = nil
}

// SetContent sets the "content" field.
func (m *TimelineEventMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *TimelineEventMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *TimelineEventMutation) ResetContent() {
	m.content = nil
}

// SetMetadata sets the "metadata" field.
func (m *TimelineEventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *TimelineEventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *TimelineEventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[timelineevent.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *TimelineEventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[timelineevent.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *TimelineEventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, timelineevent.FieldMetadata)
}

// SetLlmInteractionID sets the "llm_interaction_id" field.
func (m *TimelineEventMutation) SetLlmInteractionID(s string) {
	m.llm_interaction = &s
}

// LlmInteractionID returns the value of the "llm_interaction_id" field in the mutation.
func (m *TimelineEventMutation) LlmInteractionID() (r string, exists bool) {
	v := m.llm_interaction
	if v == nil {
		return
	}
	return *v, true
}

// OldLlmInteractionID returns the old "llm_interaction_id" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldLlmInteractionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLlmInteractionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLlmInteractionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLlmInteractionID: %w", err)
	}
	return oldValue.LlmInteractionID, nil
}

// ClearLlmInteractionID clears the value of the "llm_interaction_id" field.
func (m *TimelineEventMutation) ClearLlmInteractionID() {
	m.llm_interaction = nil
	m.clearedFields[timelineevent.FieldLlmInteractionID] = struct{}{}
}

// LlmInteractionIDCleared returns if the "llm_interaction_id" field was cleared in this mutation.
func (m *TimelineEventMutation) LlmInteractionIDCleared() bool {
	_, ok := m.clearedFields[timelineevent.FieldLlmInteractionID]
	return ok
}

// ResetLlmInteractionID resets all changes to the "llm_interaction_id" field.
func (m *TimelineEventMutation) ResetLlmInteractionID() {
	m.llm_interaction = nil
	delete(m.clearedFields, timelineevent.FieldLlmInteractionID)
}

// SetMcpInteractionID sets the "mcp_interaction_id" field.
func (m *TimelineEventMutation) SetMcpInteractionID(s string) {
	m.mcp_interaction = &s
}

// McpInteractionID returns the value of the "mcp_interaction_id" field in the mutation.
func (m *TimelineEventMutation) McpInteractionID() (r string, exists bool) {
	v := m.mcp_interaction
	if v == nil {
		return
	}
	return *v, true
}

// OldMcpInteractionID returns the old "mcp_interaction_id" field's value of the TimelineEvent entity.
// If the TimelineEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimelineEventMutation) OldMcpInteractionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMcpInteractionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMcpInteractionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMcpInteractionID: %w", err)
	}
	return oldValue.McpInteractionID, nil
}

// ClearMcpInteractionID clears the value of the "mcp_interaction_id" field.
func (m *TimelineEventMutation) ClearMcpInteractionID() {
	m.mcp_interaction = nil
	m.clearedFields[timelineevent.FieldMcpInteractionID] = struct{}{}
}

// McpInteractionIDCleared returns if the "mcp_interaction_id" field was cleared in this mutation.
func (m *TimelineEventMutation) McpInteractionIDCleared() bool {
	_, ok := m.clearedFields[timelineevent.FieldMcpInteractionID]
	return ok
}

// ResetMcpInteractionID resets all changes to the "mcp_interaction_id" field.
func (m *TimelineEventMutation) ResetMcpInteractionID() {
	m.mcp_interaction = nil
	delete(m.clearedFields, timelineevent.FieldMcpInteractionID)
}

// ClearSession clears the "session" edge to the AlertSession entity.
func (m *TimelineEventMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[timelineevent.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the AlertSession entity was cleared.
func (m *TimelineEventMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *TimelineEventMutation) SessionIDs() (ids []string) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *TimelineEventMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// ClearStage clears the "stage" edge to the Stage entity.
func (m *TimelineEventMutation) ClearStage() {
	m.clearedstage = true
	m.clearedFields[timelineevent.FieldStageID] = struct{}{}
}

// StageCleared reports if the "stage" edge to the Stage entity was cleared.
func (m *TimelineEventMutation) StageCleared() bool {
	return m.clearedstage
}

// StageIDs returns the "stage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageID instead. It exists only for internal usage by the builders.
func (m *TimelineEventMutation) StageIDs() (ids []string) {
	if id := m.stage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStage resets all changes to the "stage" edge.
func (m *TimelineEventMutation) ResetStage() {
	m.stage = nil
	m.clearedstage = false
}

// SetAgentExecutionID sets the "agent_execution" edge to the AgentExecution entity by id.
func (m *TimelineEventMutation) SetAgentExecutionID(id string) {
	m.agent_execution = &id
}

// ClearAgentExecution clears the "agent_execution" edge to the AgentExecution entity.
func (m *TimelineEventMutation) ClearAgentExecution() {
	m.clearedagent_execution = true
	m.clearedFields[timelineevent.FieldExecutionID] = struct{}{}
}

// AgentExecutionCleared reports if the "agent_execution" edge to the AgentExecution entity was cleared.
func (m *TimelineEventMutation) AgentExecutionCleared() bool {
	return m.clearedagent_execution
}

// AgentExecutionID returns the "agent_execution" edge ID in the mutation.
func (m *TimelineEventMutation) AgentExecutionID() (id string, exists bool) {
	if m.agent_execution != nil {
		return *m.agent_execution, true
	}
	return
}

// AgentExecutionIDs returns the "agent_execution" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentExecutionID instead. It exists only for internal usage by the builders.
func (m *TimelineEventMutation) AgentExecutionIDs() (ids []string) {
	if id := m.agent_execution; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgentExecution resets all changes to the "agent_execution" edge.
func (m *TimelineEventMutation) ResetAgentExecution() {
	m.agent_execution = nil
	m.clearedagent_execution = false
}

// ClearLlmInteraction clears the "llm_interaction" edge to the LLMInteraction entity.
func (m *TimelineEventMutation) ClearLlmInteraction() {
	m.clearedllm_interaction = true
	m.clearedFields[timelineevent.FieldLlmInteractionID] = struct{}{}
}

// LlmInteractionCleared reports if the "llm_interaction" edge to the LLMInteraction entity was cleared.
func (m *TimelineEventMutation) LlmInteractionCleared() bool {
	return m.LlmInteractionIDCleared() || m.clearedllm_interaction
}

// LlmInteractionIDs returns the "llm_interaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LlmInteractionID instead. It exists only for internal usage by the builders.
func (m *TimelineEventMutation) LlmInteractionIDs() (ids []string) {
	if id := m.llm_interaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLlmInteraction resets all changes to the "llm_interaction" edge.
func (m *TimelineEventMutation) ResetLlmInteraction() {
	m.llm_interaction = nil
	m.clearedllm_interaction = false
}

// ClearMcpInteraction clears the "mcp_interaction" edge to the MCPInteraction entity.
func (m *TimelineEventMutation) ClearMcpInteraction() {
	m.clearedmcp_interaction = true
	m.clearedFields[timelineevent.FieldMcpInteractionID] = struct{}{}
}

// McpInteractionCleared reports if the "mcp_interaction" edge to the MCPInteraction entity was cleared.
func (m *TimelineEventMutation) McpInteractionCleared() bool {
	return m.McpInteractionIDCleared() || m.clearedmcp_interaction
}

// McpInteractionIDs returns the "mcp_interaction" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// McpInteractionID instead. It exists only for internal usage by the builders.
func (m *TimelineEventMutation) McpInteractionIDs() (ids []string) {
	if id := m.mcp_interaction; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMcpInteraction resets all changes to the "mcp_interaction" edge.
func (m *TimelineEventMutation) ResetMcpInteraction() {
	m.mcp_interaction = nil
	m.clearedmcp_interaction = false
}

// Where appends a list predicates to the TimelineEventMutation builder.
func (m *TimelineEventMutation) Where(ps ...predicate.TimelineEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TimelineEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TimelineEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TimelineEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TimelineEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TimelineEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TimelineEvent).
func (m *TimelineEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimelineEventMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.session != nil {
		fields = append(fields, timelineevent.FieldSessionID)
	}
	if m.stage != nil {
		fields = append(fields, timelineevent.FieldStageID)
	}
	if m.agent_execution != nil {
		fields = append(fields, timelineevent.FieldExecutionID)
	}
	if m.sequence_number != nil {
		fields = append(fields, timelineevent.FieldSequenceNumber)
	}
	if m.created_at != nil {
		fields = append(fields, timelineevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, timelineevent.FieldUpdatedAt)
	}
	if m.event_type != nil {
		fields = append(fields, timelineevent.FieldEventType)
	}
	if m.status != nil {
		fields = append(fields, timelineevent.FieldStatus)
	}
	if m.content != nil {
		fields = append(fields, timelineevent.FieldContent)
	}
	if m.metadata != nil {
		fields = append(fields, timelineevent.FieldMetadata)
	}
	if m.llm_interaction != nil {
		fields = append(fields, timelineevent.FieldLlmInteractionID)
	}
	if m.mcp_interaction != nil {
		fields = append(fields, timelineevent.FieldMcpInteractionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimelineEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timelineevent.FieldSessionID:
		return m.SessionID()
	case timelineevent.FieldStageID:
		return m.StageID()
	case timelineevent.FieldExecutionID:
		return m.ExecutionID()
	case timelineevent.FieldSequenceNumber:
		return m.SequenceNumber()
	case timelineevent.FieldCreatedAt:
		return m.CreatedAt()
	case timelineevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case timelineevent.FieldEventType:
		return m.EventType()
	case timelineevent.FieldStatus:
		return m.Status()
	case timelineevent.FieldContent:
		return m.Content()
	case timelineevent.FieldMetadata:
		return m.Metadata()
	case timelineevent.FieldLlmInteractionID:
		return m.LlmInteractionID()
	case timelineevent.FieldMcpInteractionID:
		return m.McpInteractionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimelineEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timelineevent.FieldSessionID:
		return m.OldSessionID(ctx)
	case timelineevent.FieldStageID:
		return m.OldStageID(ctx)
	case timelineevent.FieldExecutionID:
		return m.OldExecutionID(ctx)
	case timelineevent.FieldSequenceNumber:
		return m.OldSequenceNumber(ctx)
	case timelineevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case timelineevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case timelineevent.FieldEventType:
		return m.OldEventType(ctx)
	case timelineevent.FieldStatus:
		return m.OldStatus(ctx)
	case timelineevent.FieldContent:
		return m.OldContent(ctx)
	case timelineevent.FieldMetadata:
		return m.OldMetadata(ctx)
	case timelineevent.FieldLlmInteractionID:
		return m.OldLlmInteractionID(ctx)
	case timelineevent.FieldMcpInteractionID:
		return m.OldMcpInteractionID(ctx)
	}
	return nil, fmt.Errorf("unknown TimelineEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimelineEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timelineevent.FieldSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case timelineevent.FieldStageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStageID(v)
		return nil
	case timelineevent.FieldExecutionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionID(v)
		return nil
	case timelineevent.FieldSequenceNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequenceNumber(v)
		return nil
	case timelineevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case timelineevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case timelineevent.FieldEventType:
		v, ok := value.(timelineevent.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case timelineevent.FieldStatus:
		v, ok := value.(timelineevent.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case timelineevent.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case timelineevent.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case timelineevent.FieldLlmInteractionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLlmInteractionID(v)
		return nil
	case timelineevent.FieldMcpInteractionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMcpInteractionID(v)
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimelineEventMutation) AddedFields() []string {
	var fields []string
	if m.addsequence_number != nil {
		fields = append(fields, timelineevent.FieldSequenceNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimelineEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timelineevent.FieldSequenceNumber:
		return m.AddedSequenceNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimelineEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timelineevent.FieldSequenceNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequenceNumber(v)
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimelineEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(timelineevent.FieldMetadata) {
		fields = append(fields, timelineevent.FieldMetadata)
	}
	if m.FieldCleared(timelineevent.FieldLlmInteractionID) {
		fields = append(fields, timelineevent.FieldLlmInteractionID)
	}
	if m.FieldCleared(timelineevent.FieldMcpInteractionID) {
		fields = append(fields, timelineevent.FieldMcpInteractionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimelineEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimelineEventMutation) ClearField(name string) error {
	switch name {
	case timelineevent.FieldMetadata:
		m.ClearMetadata()
		return nil
	case timelineevent.FieldLlmInteractionID:
		m.ClearLlmInteractionID()
		return nil
	case timelineevent.FieldMcpInteractionID:
		m.ClearMcpInteractionID()
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimelineEventMutation) ResetField(name string) error {
	switch name {
	case timelineevent.FieldSessionID:
		m.ResetSessionID()
		return nil
	case timelineevent.FieldStageID:
		m.ResetStageID()
		return nil
	case timelineevent.FieldExecutionID:
		m.ResetExecutionID()
		return nil
	case timelineevent.FieldSequenceNumber:
		m.ResetSequenceNumber()
		return nil
	case timelineevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case timelineevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case timelineevent.FieldEventType:
		m.ResetEventType()
		return nil
	case timelineevent.FieldStatus:
		m.ResetStatus()
		return nil
	case timelineevent.FieldContent:
		m.ResetContent()
		return nil
	case timelineevent.FieldMetadata:
		m.ResetMetadata()
		return nil
	case timelineevent.FieldLlmInteractionID:
		m.ResetLlmInteractionID()
		return nil
	case timelineevent.FieldMcpInteractionID:
		m.ResetMcpInteractionID()
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimelineEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.session != nil {
		edges = append(edges, timelineevent.EdgeSession)
	}
	if m.stage != nil {
		edges = append(edges, timelineevent.EdgeStage)
	}
	if m.agent_execution != nil {
		edges = append(edges, timelineevent.EdgeAgentExecution)
	}
	if m.llm_interaction != nil {
		edges = append(edges, timelineevent.EdgeLlmInteraction)
	}
	if m.mcp_interaction != nil {
		edges = append(edges, timelineevent.EdgeMcpInteraction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimelineEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timelineevent.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case timelineevent.EdgeStage:
		if id := m.stage; id != nil {
			return []ent.Value{*id}
		}
	case timelineevent.EdgeAgentExecution:
		if id := m.agent_execution; id != nil {
			return []ent.Value{*id}
		}
	case timelineevent.EdgeLlmInteraction:
		if id := m.llm_interaction; id != nil {
			return []ent.Value{*id}
		}
	case timelineevent.EdgeMcpInteraction:
		if id := m.mcp_interaction; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimelineEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimelineEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimelineEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedsession {
		edges = append(edges, timelineevent.EdgeSession)
	}
	if m.clearedstage {
		edges = append(edges, timelineevent.EdgeStage)
	}
	if m.clearedagent_execution {
		edges = append(edges, timelineevent.EdgeAgentExecution)
	}
	if m.clearedllm_interaction {
		edges = append(edges, timelineevent.EdgeLlmInteraction)
	}
	if m.clearedmcp_interaction {
		edges = append(edges, timelineevent.EdgeMcpInteraction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimelineEventMutation) EdgeCleared(name string) bool {
	switch name {
	case timelineevent.EdgeSession:
		return m.clearedsession
	case timelineevent.EdgeStage:
		return m.clearedstage
	case timelineevent.EdgeAgentExecution:
		return m.clearedagent_execution
	case timelineevent.EdgeLlmInteraction:
		return m.clearedllm_interaction
	case timelineevent.EdgeMcpInteraction:
		return m.clearedmcp_interaction
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimelineEventMutation) ClearEdge(name string) error {
	switch name {
	case timelineevent.EdgeSession:
		m.ClearSession()
		return nil
	case timelineevent.EdgeStage:
		m.ClearStage()
		return nil
	case timelineevent.EdgeAgentExecution:
		m.ClearAgentExecution()
		return nil
	case timelineevent.EdgeLlmInteraction:
		m.ClearLlmInteraction()
		return nil
	case timelineevent.EdgeMcpInteraction:
		m.ClearMcpInteraction()
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimelineEventMutation) ResetEdge(name string) error {
	switch name {
	case timelineevent.EdgeSession:
		m.ResetSession()
		return nil
	case timelineevent.EdgeStage:
		m.ResetStage()
		return nil
	case timelineevent.EdgeAgentExecution:
		m.ResetAgentExecution()
		return nil
	case timelineevent.EdgeLlmInteraction:
		m.ResetLlmInteraction()
		return nil
	case timelineevent.EdgeMcpInteraction:
		m.ResetMcpInteraction()
		return nil
	}
	return fmt.Errorf("unknown TimelineEvent edge %s", name)
}
