# TARSy Main Configuration File
# Copy this file to tarsy.yaml and customize for your environment
#
# cp tarsy.yaml.example tarsy.yaml
#
# IMPORTANT: This file uses environment variable interpolation.
# - Use {{.VAR_NAME}} syntax to reference environment variables (Go template syntax)
# - Literal $ characters (in passwords, regexes, etc.) are preserved as-is
# - Configure actual values in your .env file (copy from .env.example)
# - Built-in agents/MCP servers/chains can be overridden by defining same name/ID

# =============================================================================
# QUEUE & WORKER POOL CONFIGURATION
# =============================================================================
# Controls how sessions are polled, claimed, and processed by workers.
# All values below are defaults â€” override as needed for your deployment.

queue:
  # Number of worker goroutines per replica/pod
  worker_count: 5

  # Maximum concurrent sessions across ALL replicas (global DB-based limit)
  max_concurrent_sessions: 5

  # Poll interval for checking pending sessions (with jitter to prevent thundering herd)
  poll_interval: 1s
  poll_interval_jitter: 500ms

  # Session processing timeout (max time per session)
  session_timeout: 15m

  # Graceful shutdown timeout (should match session_timeout)
  # Kubernetes terminationGracePeriodSeconds must be >= this value
  graceful_shutdown_timeout: 15m

  # Orphan detection: scans for stuck in_progress sessions with stale heartbeats
  orphan_detection_interval: 5m
  orphan_threshold: 5m

# =============================================================================
# SYSTEM-WIDE INFRASTRUCTURE SETTINGS
# =============================================================================
# GitHub integration, runbooks, Slack notifications, and shared URLs.

system:
  # Base URL for dashboard links (used in Slack notifications, etc.)
  dashboard_url: "https://tarsy.example.com"  # Default: http://localhost:5173

  # GitHub integration for fetching runbooks from private repos
  github:
    token_env: "GITHUB_TOKEN"  # Env var containing GitHub PAT (default: GITHUB_TOKEN)

  # Runbook system configuration
  runbooks:
    repo_url: "https://github.com/org/repo/tree/main/runbooks"
    cache_ttl: "1m"                 # Cache duration (default: 1m)
    allowed_domains:                # URL domain allowlist (default below)
      - "github.com"
      - "raw.githubusercontent.com"

  # Slack notification configuration
  # Sends notifications when sessions start, complete, fail, or time out.
  # Requires a Slack Bot Token with scopes: channels:history, groups:history, chat:write
  # To enable: set enabled: true, provide a valid channel ID, and ensure the
  # token env var (default: SLACK_BOT_TOKEN) is set in your environment.
  # NOTE: For local dev, set enabled: true and configure SLACK_BOT_TOKEN in .env
  # to receive Slack notifications out of the box.
  slack:
    enabled: false
    token_env: "SLACK_BOT_TOKEN"   # Env var name for bot token (default: SLACK_BOT_TOKEN)
    channel: "C12345678"           # Slack channel ID (required when enabled)

  # Data retention and cleanup (all values below are defaults)
  retention:
    session_retention_days: 365      # Soft-delete completed sessions older than N days
    event_ttl: 1h                    # Delete orphaned Event rows older than this
    cleanup_interval: 12h            # How often the cleanup loop runs

# =============================================================================
# SYSTEM-WIDE DEFAULTS
# =============================================================================
# These values are used when components don't specify their own values

defaults:
  # Default LLM provider for all agents/chains
  llm_provider: "google-default"
  
  # Default max iterations (forces conclusion when reached, no pause/resume)
  max_iterations: 20
  
  # Default iteration strategy
  iteration_strategy: "langchain"
  
  # Default success policy for parallel stages ("all" or "any")
  success_policy: "any"
  
  # Default scoring agent name (fallback when chain has no scoring config)
  scoring_agent: "ScoringAgent"
  
  # Default alert type for new sessions (used in UI dropdown)
  alert_type: "kubernetes"
  
  # Alert data masking configuration
  # Masks sensitive data in alert payloads before DB storage
  alert_masking:
    enabled: true
    pattern_group: "security"  # Options: basic, secrets, security, kubernetes, cloud, all

  # Default runbook content for new sessions
  # Override with your organization's troubleshooting guide
  runbook: |
    # Company Troubleshooting Guide
    
    ## Investigation Steps
    1. Check monitoring dashboards
    2. Review recent deployments
    3. Analyze logs and metrics
    4. Contact on-call engineer if needed
    
    ## Internal Resources
    - Runbook wiki: https://wiki.company.com/runbooks
    - Escalation: #oncall-team

# =============================================================================
# MCP SERVER CONFIGURATIONS
# =============================================================================
# Define MCP servers that agents can use
# Built-in: kubernetes-server (can be overridden)

mcp_servers:
  # Override built-in kubernetes-server with custom configuration
  kubernetes-server:
    transport:
      type: "stdio"
      command: "npx"
      args:
        - "-y"
        - "kubernetes-mcp-server@0.0.54"
        - "--read-only"
        - "--disable-destructive"
        - "--kubeconfig"
        - "{{.KUBECONFIG}}"
    
    instructions: |
      For Kubernetes operations:
      - **IMPORTANT: In multi-cluster environments** (when 'configuration_contexts_list' tool is available):
        * ALWAYS start by calling 'configuration_contexts_list' to see all available contexts
        * Use this information to determine which context to target before performing operations
      - Be careful with cluster-scoped resource listings in large clusters
      - Always prefer namespaced queries when possible
      - If you get "server could not find the requested resource" error:
        * Cluster-scoped resources (Namespace, Node, ClusterRole) should NOT have namespace parameter
        * Namespace-scoped resources (Pod, Deployment, Service) REQUIRE namespace parameter
    
    data_masking:
      enabled: true
      pattern_groups:
        - "kubernetes"  # Expands to: certificate_authority_data, api_key, password, token
      patterns:
        - "certificate"
        - "token"
        - "email"
      # custom_patterns:  # Optional: define your own patterns
      #   - pattern: "CUSTOM_SECRET_.*"
      #     replacement: "[MASKED_CUSTOM]"
      #     description: "Custom secret pattern"
    
    summarization:
      enabled: true
      size_threshold_tokens: 5000
      summary_max_token_limit: 1000

  # Example: ArgoCD MCP server
  argocd-server:
    transport:
      type: "stdio"
      command: "npx"
      args:
        - "-y"
        - "argocd-mcp-server@latest"
        - "--server"
        - "{{.ARGOCD_SERVER}}"
        - "--auth-token"
        - "{{.ARGOCD_TOKEN}}"
    
    instructions: |
      For ArgoCD operations:
      - Check application sync status and health first
      - Look at sync operations and their results
      - Consider GitOps workflow and source repository state
      - Pay attention to resource hooks and sync waves
    
    data_masking:
      enabled: true
      pattern_groups: ["kubernetes"]
      patterns: ["certificate", "token"]
    
    summarization:
      enabled: true
      size_threshold_tokens: 3000

  # Example: HTTP-based MCP server
  monitoring-server:
    transport:
      type: "http"
      url: "{{.MONITORING_MCP_URL}}"
      bearer_token: "{{.MONITORING_TOKEN}}"
      verify_ssl: true  # Keep enabled for production; only disable (false) for local testing with self-signed certs
      timeout: 30
    
    instructions: |
      For monitoring operations:
      - Query metrics for the last 24 hours by default
      - Focus on anomalies and trends
      - Consider baseline metrics for comparison
    
    data_masking:
      enabled: true
      patterns: ["email", "token"]
    
    summarization:
      enabled: true
      size_threshold_tokens: 4000

# =============================================================================
# CUSTOM AGENT DEFINITIONS
# =============================================================================
# Define custom agents or override built-in agents
# Built-in agents: KubernetesAgent, ChatAgent, SynthesisAgent, ScoringAgent

agents:
  # Example: Security-focused agent
  security-agent:
    mcp_servers:
      - "kubernetes-server"
      - "argocd-server"
    iteration_strategy: "langchain"
    max_iterations: 25
    custom_instructions: |
      You are a security-focused SRE agent specializing in cybersecurity incidents.
      
      PRIORITIES:
      1. Data security and compliance over service availability
      2. Immediate containment of security threats
      3. Detailed forensic analysis and documentation
      
      APPROACH:
      - Immediately assess the severity and scope of security incidents
      - Take containment actions to prevent further damage
      - Gather evidence and maintain chain of custody
      - Provide clear recommendations for remediation

  # Example: Performance-focused agent
  performance-agent:
    mcp_servers:
      - "monitoring-server"
      - "kubernetes-server"
    iteration_strategy: "langchain"
    custom_instructions: |
      You are a performance-focused SRE agent specializing in system optimization.
      
      Focus on identifying root causes of performance bottlenecks and
      providing actionable recommendations for optimization.

  # Example: Override built-in KubernetesAgent
  KubernetesAgent:
    mcp_servers:
      - "kubernetes-server"
      - "argocd-server"  # Add ArgoCD support
    custom_instructions: |
      You are a Kubernetes expert with deep knowledge of container orchestration.
      
      When investigating issues:
      - Start by understanding the current state
      - Check for recent changes (deployments, config changes)
      - Examine logs, events, and resource status
      - Consider dependencies and external factors
      - Provide clear, actionable recommendations

  # Example: Override built-in ChatAgent
  # ChatAgent inherits MCP servers from chain stages via aggregation,
  # so you typically don't set mcp_servers here.
  # ChatAgent:
  #   custom_instructions: |
  #     You are a follow-up chat agent for SRE investigations.
  #     Use the investigation results to answer questions concisely.

  # Example: Override built-in SynthesisAgent
  # SynthesisAgent combines results from parallel investigation agents.
  # It doesn't call tools, so mcp_servers is typically empty.
  # SynthesisAgent:
  #   iteration_strategy: "synthesis-native-thinking"
  #   custom_instructions: |
  #     You are an Incident Commander synthesizing parallel investigation results.
  #     Produce a unified diagnosis with severity, root cause, and remediation steps.

  # Example: Override built-in ScoringAgent
  # ScoringAgent evaluates session quality after investigation completes.
  # iteration_strategy MUST be a scoring strategy: "scoring" or "scoring-native-thinking".
  # Chain-level iteration_strategy does NOT inherit into scoring resolution.
  # ScoringAgent:
  #   iteration_strategy: "scoring"
  #   custom_instructions: |
  #     You are a session quality evaluator.
  #     Score the investigation based on thoroughness, accuracy, and actionability.

# =============================================================================
# AGENT CHAIN DEFINITIONS
# =============================================================================
# Define multi-stage agent chains for different alert types
# Built-in chains: kubernetes-agent-chain

agent_chains:
  # Single-stage chain with native thinking
  kubernetes-pod-crashloop:
    alert_types: ["PodCrashLoop", "PodCrashLoopBackOff"]
    description: "Deep Kubernetes troubleshooting for crash loops"
    stages:
      - name: "Investigation"
        agents:
          - name: "KubernetesAgent"
            iteration_strategy: "native-thinking"
            max_iterations: 15
    chat:
      enabled: true
      agent: "ChatAgent"
    scoring:
      enabled: true
      agent: "ScoringAgent"
      iteration_strategy: "scoring"  # Must be "scoring" or "scoring-native-thinking"
      llm_provider: "google-default"
      max_iterations: 5

  # Multi-stage chain with different strategies
  kubernetes-deep-troubleshooting:
    alert_types: ["PodCrashLoop - Multi-Stage"]
    description: "2-stage deep Kubernetes troubleshooting"
    stages:
      - name: "system-data-collection"
        agents:
          - name: "KubernetesAgent"
            iteration_strategy: "langchain"
        max_iterations: 10
      
      - name: "final-diagnosis"
        agents:
          - name: "KubernetesAgent"
            iteration_strategy: "native-thinking"
        max_iterations: 5

  # Multiple agents in parallel with synthesis
  kubernetes-multiple-agents:
    alert_types: ["Kubernetes - Multiple Agents"]
    description: "Multiple agents with custom synthesis"
    llm_provider: "google-default"
    stages:
      - name: "Investigation"
        max_iterations: 10
        agents:
          - name: "KubernetesAgent"
            iteration_strategy: "native-thinking"
            llm_provider: "gemini-2.5-flash"
            max_iterations: 10
          
          - name: "KubernetesAgent"
            iteration_strategy: "langchain"
            llm_provider: "gemini-2.5-flash"
            max_iterations: 3
          
          - name: "performance-agent"
            iteration_strategy: "native-thinking"
            llm_provider: "gemini-2.5-pro"
        
        synthesis:
          agent: "SynthesisAgent"
          iteration_strategy: "synthesis-native-thinking"
          llm_provider: "gemini-3-pro"

  # Replica chain (run same agent multiple times)
  kubernetes-2-replicas:
    alert_types: ["Kubernetes - Replicas"]
    description: "2 replicas of same agent for redundancy"
    llm_provider: "gemini-2.5-flash"
    stages:
      - name: "replicas"
        agents:
          - name: "KubernetesAgent"
        replicas: 2  # Run KubernetesAgent twice

  # Security incident chain
  security-incident:
    alert_types: ["SecurityIncident", "IntrusionDetection"]
    description: "Security-focused investigation"
    stages:
      - name: "triage"
        agents:
          - name: "security-agent"
            iteration_strategy: "langchain"
            max_iterations: 30
    chat:
      enabled: true
      agent: "ChatAgent"
      max_iterations: 20
